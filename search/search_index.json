{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Quick-DEV framework Introduction QuickDev framework is designed to provide enhanced SDK middleware and product ready application reference codes to help developer for fast development. Below diagram is the whole Opulinks provided software architecture combined with QuickDev framework and Opulinks Tritium SDK. App Reference - Provides reference firmware for a complete product demonstration, the application developers can reference the source code and decide which modules to use for fast product developement. Enhanced Middleware - The middleware layer is to integrate common useful functions and features to minimize the effort for application developer for any applications. Tritium SDK - The SDK provided by Opulinks Opulinks github Advantage To provide an easy entry to develop IoT application. To provide application reference modules consist of complete IoT application functions. To provide enhanced Opulinks SDK middleware. Modelized architecture, fulfills different vendor requirement. To provide easy configuration mechanism to config different kind of applications and different modules. To provide cloud template to adapt public/private cloud. To provide pratical usage examples to facilitate developing.","title":"Introduction"},{"location":"#welcome-to-quick-dev-framework","text":"","title":"Welcome to Quick-DEV framework"},{"location":"#introduction","text":"QuickDev framework is designed to provide enhanced SDK middleware and product ready application reference codes to help developer for fast development. Below diagram is the whole Opulinks provided software architecture combined with QuickDev framework and Opulinks Tritium SDK. App Reference - Provides reference firmware for a complete product demonstration, the application developers can reference the source code and decide which modules to use for fast product developement. Enhanced Middleware - The middleware layer is to integrate common useful functions and features to minimize the effort for application developer for any applications. Tritium SDK - The SDK provided by Opulinks Opulinks github","title":"Introduction"},{"location":"#advantage","text":"To provide an easy entry to develop IoT application. To provide application reference modules consist of complete IoT application functions. To provide enhanced Opulinks SDK middleware. Modelized architecture, fulfills different vendor requirement. To provide easy configuration mechanism to config different kind of applications and different modules. To provide cloud template to adapt public/private cloud. To provide pratical usage examples to facilitate developing.","title":"Advantage"},{"location":"api-reference/ble_apis/","text":"BLE (API List)","title":"BluetoothLE"},{"location":"api-reference/ble_apis/#ble-api-list","text":"","title":"BLE (API List)"},{"location":"api-reference/cloud_apis/","text":"Cloud (API List)","title":"Cloud"},{"location":"api-reference/cloud_apis/#cloud-api-list","text":"","title":"Cloud (API List)"},{"location":"api-reference/ota_apis/","text":"OTA (API List)","title":"OTA"},{"location":"api-reference/ota_apis/#ota-api-list","text":"","title":"OTA (API List)"},{"location":"api-reference/wifi_apis/","text":"WI-FI Network Manager Network Manager provide support for configuring and monitoring WI-FI networking functionality. We stronly recommend using NM, because NM could help network robust. Header File net_mngr.h Functions T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Description Trigger WI-FI scan request, and carried the scan result in indicate callback Parameters fpIndCb : indicate callback function pointer (if required) Returns T_OplErr : see in opl_err.h WI-FI Manager","title":"WI-FI"},{"location":"api-reference/wifi_apis/#wi-fi","text":"","title":"WI-FI"},{"location":"api-reference/wifi_apis/#network-manager","text":"Network Manager provide support for configuring and monitoring WI-FI networking functionality. We stronly recommend using NM, because NM could help network robust.","title":"Network Manager"},{"location":"api-reference/wifi_apis/#header-file","text":"net_mngr.h","title":"Header File"},{"location":"api-reference/wifi_apis/#functions","text":"T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Description Trigger WI-FI scan request, and carried the scan result in indicate callback Parameters fpIndCb : indicate callback function pointer (if required) Returns T_OplErr : see in opl_err.h","title":"Functions"},{"location":"api-reference/wifi_apis/#wi-fi-manager","text":"","title":"WI-FI Manager"},{"location":"application-guide/ble/","text":"BluetoothLE BLE Manager BLE manager provide the auto-advertise option and handling the BLE status that make user eaiser to control BLE statment. Initialize Before using the BLE manager, please follow below steps to initiate. Step 1. Enable BLE manager #define BM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder. Step 2. Add related file in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // initialize ble scan response data APP_BleScanRspDataInit(); break; } case USLCTED_CB_EVT_BLE_ENT_ADVERTISE: { // enter advertising event break; } case USLCTED_CB_EVT_BLE_EXI_ADVERTISE: { // exit advertising event break; } case USLCTED_CB_EVT_BLE_CONNECTED: { // ble connected event break; } case USLCTED_CB_EVT_BLE_DISCONNECT: { // ble disconnect event break; } default: { // should not be here break; } } } void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // ...register your service here // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } The parameter of Opl_Ble_Init_Req() is to enable/disable auto-advertise function. If set as true - the auto-advertise will be enabled, and will directly start advertise after ble manager init done. While disconnect from connected state, ble manager will also start advertising, till user calling Opl_Ble_Stop_Req() . If set as false - the auto-advertise will be disabled, and will not advertise after ble manager init done. Info The APP_BleInit() function create by default in app_main.c , it's for developer to fill the ble related init function in it. Step 4. Setup advertise data void APP_BleAdvDataInit(void) { // ble advertise data inititate // user modify // * uint8_t au8BleAdvertData[]; // configure your own advertise data Opl_Ble_Advertise_Data_Set(au8BleAdvertData, lens); // * } Step 5. Setup scan response data Create scan response data init function, and modify your wishes data. void APP_BleScanRspDataInit(void) { // ble scan response data inititate // user modify // * uint8_t au8BleScanRspData[BLE_ADV_SCAN_BUF_SIZE]; // configure your own scan response data if(OPL_OK != Opl_Ble_ScanRsp_Data_Set(au8BleScanRspData, lens)) { OPL_LOG_ERRO(APP, \"Scan Rsp Data Set Fail\"); } // * } Step 6. Call set adv data & scan rsp data after init Call APP_BleAdvDataInit (created in step 4) and APP_BleScanRspDataInit (created in step 5) after recevied USLCTED_CB_EVT_BLE_INIT event in ble unsolicited callback. void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // <--- // initialize ble scan response data APP_BleScanRspDataInit(); // <--- break; } Unsolicited callback The unsolicited callback will content with ble status and carried the result in each state. Info Unsolicited callback prototype located in ble_mngr_api.h Register service Descript how to create the service file How To... BLE Manager The BLE manager should provide a mechanism for user BLE data processing application to register the user (vendor defined) service table. The user data processing application process the data receive from and transmit to the phone App via BLE. Developer could set a file for specific service in quick_dev\\ble_services How to create BLE service BLE service initiate (e.g. Battery Service) void BAS_Svc_Init(void) { g_tBasSvcHandle.patSvcDb = g_BasSvcDb; g_tBasSvcHandle.u8SvcDbSize = BAS_SVC_IDX_TOTAL; g_tBasSvcHandle.ptSvcGattDispatchHandler = BAS_Svc_GattDispatchHandler; if(OPL_OK != Opl_Ble_Service_Assign(&g_tBasSvcHandle)) { OPL_LOG_ERRO(BAS, \"BAS Service assign fail\\r\\n\"); } } g_tBasSvcHandle is the BLE service handle structure static T_BmSvcHandle g_tBasSvcHandle = {0}; typedef struct S_BmSvcHandle { LE_GATT_SERVICE_T *ptSvcDef; LE_GATT_ATTR_T *patSvcDb; uint8_t u8SvcDbSize; uint8_t u8Reserved; uint16_t u16SvcDataEvtBase; uint16_t u16SvcDataEvtTop; T_BmSvcDataProcessHandlerFp ptSvcDataProcessHandler; T_BmSvcGattDispatchHandlerFp ptSvcGattDispatchHandler; } T_BmSvcHandle; Developer at least should set three parameters *patSvcDb , u8SvcDbSize and ptSvcGattDispatchHandler . *patSvcDb is the service attribute information. u8SvcDbSize is the service size and ptSvcGattDispatchHandler is GATT dispatch handler. LE_GATT_ATTR_T *patSvcDb; typedef struct { UINT16 handle; /**< handle */ UINT8 format; /**< UUID type */ UINT16 * const pUuid; /**< UUID */ UINT16 permit; /**< permit */ UINT16 maxLen; /**< maxinum value length */ UINT16 len; /**< value length */ UINT8 * const pVal; /**< value */ } LE_GATT_ATTR_T; After configurating the BLE handle structure, developer could register BLE service via BLE Manager. Register BLE service via BLE Manager T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle) How to receive/notify data via BLE Developer could create user defined service to implement input/output via BLE. Receive data via BLE In user defined servcie, developer can use user defined GATT dispatch handler to handle data from LE task. The developer can create different handlers for processing according to the type of data received in user defined GATT dispatch handler. static T_OplErr UD_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { UD_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { UD_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { OPL_LOG_INFO(UDS, \"Notify Confirm\"); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } There are three types of events in user defined handler that incude LE_GATT_MSG_ACCESS_READ_IND , LE_GATT_MSG_ACCESS_WRITE_IND and LE_GATT_MSG_NOTIFY_CFM . Developer could create different handler to handle these events. If receiving LE_GATT_MSG_ACCESS_WRITE_IND , developer could create write handler (e.g. UD_Svc_GattDispatchWriteHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessWriteRsp . static void UD_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_TX_VAL: { // send message to app APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case UD_SVC_IDX_RX_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, UD_SVC_IDX_RX_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } LeGattAccessWriteRsp(ind->conn_hdl, ind->flag, ind->handle, u8AttErr); } If receiving LE_GATT_MSG_ACCESS_READ_IND , developer could create read handler (e.g. UD_Svc_GattDispatchReadHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessReadRsp . static void UD_Svc_GattDispatchReadHandler(LE_GATT_MSG_ACCESS_READ_IND_T *ind) { // process the read access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_RX_VAL: case UD_SVC_IDX_RX_CFG: { break; } default: { u8AttErr = LE_ATT_ERR_READ_NOT_PERMITTED; break; } } LeGattAccessReadRsp(ind->conn_hdl, ind->handle, u8AttErr); } Notify data via BLE If wanting to actively send messages from application to the host via BLE, developer can create a notify function (e.g. UD_Svc_RxDataOutNotify ) in the user defined service. LeGattCharValNotify can send data via LE. T_OplErr UD_Svc_RxDataOutNotify(uint8_t *pu8Data, uint32_t u32DataLen) { LE_ERR_STATE status; uint16_t u16NotiAttrId = g_tUdSvcHandle.ptSvcDef->startHdl + UD_SVC_IDX_RX_VAL; // update rx data to attribute value LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, (uint16_t)UD_SVC_IDX_RX_VAL, u32DataLen, pu8Data); // notify rx data to host status = LeGattCharValNotify(Opl_Ble_EntityGet()->conn_hdl, u16NotiAttrId, u32DataLen, pu8Data); if (status != SYS_ERR_SUCCESS) { OPL_LOG_ERRO(BAS, \"Ble sending data fail\"); return OPL_ERR; } return OPL_OK; } How to perform BLE process Start BLE advertising T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn) To start BLE advertising, *u8AutoAdvEn is true that enable auto-advertise while disconnect. Stop BLE advertisng T_OplErr Opl_Ble_Stop_Req(void) Set BLE advertise data T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen) If wanting to set BLE advertisement data via BLE Manager, developer could config BLE data *pau8AdvData in Opl_Ble_Advertise_Data_Set Set BLE scan respnse data T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen) If BLE central scan, developer could set scan response data in BLE perpherial","title":"BluetoothLE"},{"location":"application-guide/ble/#bluetoothle","text":"","title":"BluetoothLE"},{"location":"application-guide/ble/#ble-manager","text":"BLE manager provide the auto-advertise option and handling the BLE status that make user eaiser to control BLE statment.","title":"BLE Manager"},{"location":"application-guide/ble/#initialize","text":"Before using the BLE manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/ble/#step-1-enable-ble-manager","text":"#define BM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder.","title":"Step 1. Enable BLE manager"},{"location":"application-guide/ble/#step-2-add-related-file-in-keil-project","text":"","title":"Step 2. Add related file in Keil project"},{"location":"application-guide/ble/#step-3-register-callback-and-init","text":"Add below program in app_main.c void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // initialize ble scan response data APP_BleScanRspDataInit(); break; } case USLCTED_CB_EVT_BLE_ENT_ADVERTISE: { // enter advertising event break; } case USLCTED_CB_EVT_BLE_EXI_ADVERTISE: { // exit advertising event break; } case USLCTED_CB_EVT_BLE_CONNECTED: { // ble connected event break; } case USLCTED_CB_EVT_BLE_DISCONNECT: { // ble disconnect event break; } default: { // should not be here break; } } } void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // ...register your service here // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } The parameter of Opl_Ble_Init_Req() is to enable/disable auto-advertise function. If set as true - the auto-advertise will be enabled, and will directly start advertise after ble manager init done. While disconnect from connected state, ble manager will also start advertising, till user calling Opl_Ble_Stop_Req() . If set as false - the auto-advertise will be disabled, and will not advertise after ble manager init done. Info The APP_BleInit() function create by default in app_main.c , it's for developer to fill the ble related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/ble/#step-4-setup-advertise-data","text":"void APP_BleAdvDataInit(void) { // ble advertise data inititate // user modify // * uint8_t au8BleAdvertData[]; // configure your own advertise data Opl_Ble_Advertise_Data_Set(au8BleAdvertData, lens); // * }","title":"Step 4. Setup advertise data"},{"location":"application-guide/ble/#step-5-setup-scan-response-data","text":"Create scan response data init function, and modify your wishes data. void APP_BleScanRspDataInit(void) { // ble scan response data inititate // user modify // * uint8_t au8BleScanRspData[BLE_ADV_SCAN_BUF_SIZE]; // configure your own scan response data if(OPL_OK != Opl_Ble_ScanRsp_Data_Set(au8BleScanRspData, lens)) { OPL_LOG_ERRO(APP, \"Scan Rsp Data Set Fail\"); } // * }","title":"Step 5. Setup scan response data"},{"location":"application-guide/ble/#step-6-call-set-adv-data-scan-rsp-data-after-init","text":"Call APP_BleAdvDataInit (created in step 4) and APP_BleScanRspDataInit (created in step 5) after recevied USLCTED_CB_EVT_BLE_INIT event in ble unsolicited callback. void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // <--- // initialize ble scan response data APP_BleScanRspDataInit(); // <--- break; }","title":"Step 6. Call set adv data &amp; scan rsp data after init"},{"location":"application-guide/ble/#unsolicited-callback","text":"The unsolicited callback will content with ble status and carried the result in each state. Info Unsolicited callback prototype located in ble_mngr_api.h","title":"Unsolicited callback"},{"location":"application-guide/ble/#register-service","text":"Descript how to create the service file","title":"Register service"},{"location":"application-guide/ble/#how-to","text":"","title":"How To..."},{"location":"application-guide/ble/#ble-manager_1","text":"The BLE manager should provide a mechanism for user BLE data processing application to register the user (vendor defined) service table. The user data processing application process the data receive from and transmit to the phone App via BLE. Developer could set a file for specific service in quick_dev\\ble_services","title":"BLE Manager"},{"location":"application-guide/ble/#how-to-create-ble-service","text":"BLE service initiate (e.g. Battery Service) void BAS_Svc_Init(void) { g_tBasSvcHandle.patSvcDb = g_BasSvcDb; g_tBasSvcHandle.u8SvcDbSize = BAS_SVC_IDX_TOTAL; g_tBasSvcHandle.ptSvcGattDispatchHandler = BAS_Svc_GattDispatchHandler; if(OPL_OK != Opl_Ble_Service_Assign(&g_tBasSvcHandle)) { OPL_LOG_ERRO(BAS, \"BAS Service assign fail\\r\\n\"); } } g_tBasSvcHandle is the BLE service handle structure static T_BmSvcHandle g_tBasSvcHandle = {0}; typedef struct S_BmSvcHandle { LE_GATT_SERVICE_T *ptSvcDef; LE_GATT_ATTR_T *patSvcDb; uint8_t u8SvcDbSize; uint8_t u8Reserved; uint16_t u16SvcDataEvtBase; uint16_t u16SvcDataEvtTop; T_BmSvcDataProcessHandlerFp ptSvcDataProcessHandler; T_BmSvcGattDispatchHandlerFp ptSvcGattDispatchHandler; } T_BmSvcHandle; Developer at least should set three parameters *patSvcDb , u8SvcDbSize and ptSvcGattDispatchHandler . *patSvcDb is the service attribute information. u8SvcDbSize is the service size and ptSvcGattDispatchHandler is GATT dispatch handler. LE_GATT_ATTR_T *patSvcDb; typedef struct { UINT16 handle; /**< handle */ UINT8 format; /**< UUID type */ UINT16 * const pUuid; /**< UUID */ UINT16 permit; /**< permit */ UINT16 maxLen; /**< maxinum value length */ UINT16 len; /**< value length */ UINT8 * const pVal; /**< value */ } LE_GATT_ATTR_T; After configurating the BLE handle structure, developer could register BLE service via BLE Manager. Register BLE service via BLE Manager T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle)","title":"How to create BLE service"},{"location":"application-guide/ble/#how-to-receivenotify-data-via-ble","text":"Developer could create user defined service to implement input/output via BLE. Receive data via BLE In user defined servcie, developer can use user defined GATT dispatch handler to handle data from LE task. The developer can create different handlers for processing according to the type of data received in user defined GATT dispatch handler. static T_OplErr UD_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { UD_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { UD_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { OPL_LOG_INFO(UDS, \"Notify Confirm\"); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } There are three types of events in user defined handler that incude LE_GATT_MSG_ACCESS_READ_IND , LE_GATT_MSG_ACCESS_WRITE_IND and LE_GATT_MSG_NOTIFY_CFM . Developer could create different handler to handle these events. If receiving LE_GATT_MSG_ACCESS_WRITE_IND , developer could create write handler (e.g. UD_Svc_GattDispatchWriteHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessWriteRsp . static void UD_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_TX_VAL: { // send message to app APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case UD_SVC_IDX_RX_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, UD_SVC_IDX_RX_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } LeGattAccessWriteRsp(ind->conn_hdl, ind->flag, ind->handle, u8AttErr); } If receiving LE_GATT_MSG_ACCESS_READ_IND , developer could create read handler (e.g. UD_Svc_GattDispatchReadHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessReadRsp . static void UD_Svc_GattDispatchReadHandler(LE_GATT_MSG_ACCESS_READ_IND_T *ind) { // process the read access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_RX_VAL: case UD_SVC_IDX_RX_CFG: { break; } default: { u8AttErr = LE_ATT_ERR_READ_NOT_PERMITTED; break; } } LeGattAccessReadRsp(ind->conn_hdl, ind->handle, u8AttErr); } Notify data via BLE If wanting to actively send messages from application to the host via BLE, developer can create a notify function (e.g. UD_Svc_RxDataOutNotify ) in the user defined service. LeGattCharValNotify can send data via LE. T_OplErr UD_Svc_RxDataOutNotify(uint8_t *pu8Data, uint32_t u32DataLen) { LE_ERR_STATE status; uint16_t u16NotiAttrId = g_tUdSvcHandle.ptSvcDef->startHdl + UD_SVC_IDX_RX_VAL; // update rx data to attribute value LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, (uint16_t)UD_SVC_IDX_RX_VAL, u32DataLen, pu8Data); // notify rx data to host status = LeGattCharValNotify(Opl_Ble_EntityGet()->conn_hdl, u16NotiAttrId, u32DataLen, pu8Data); if (status != SYS_ERR_SUCCESS) { OPL_LOG_ERRO(BAS, \"Ble sending data fail\"); return OPL_ERR; } return OPL_OK; }","title":"How to receive/notify data via BLE"},{"location":"application-guide/ble/#how-to-perform-ble-process","text":"Start BLE advertising T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn) To start BLE advertising, *u8AutoAdvEn is true that enable auto-advertise while disconnect. Stop BLE advertisng T_OplErr Opl_Ble_Stop_Req(void) Set BLE advertise data T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen) If wanting to set BLE advertisement data via BLE Manager, developer could config BLE data *pau8AdvData in Opl_Ble_Advertise_Data_Set Set BLE scan respnse data T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen) If BLE central scan, developer could set scan response data in BLE perpherial","title":"How to perform BLE process"},{"location":"application-guide/board_config/","text":"Board Configuration Descript","title":"Board Configuration"},{"location":"application-guide/board_config/#board-configuration","text":"Descript","title":"Board Configuration"},{"location":"application-guide/cloud/","text":"Cloud Cloud Template Cloud Template is a template architecture that help developer to integrate the device with the public/private cloud service and achieve the low power consumption and short latency purpose. There two components in Cloud Template, the Cloud Kernel and Cloud Control. Three tasks will be created in Cloud Kernel, they are Cloud TX task, Cloud RX task, and Cloud OTA task. Cloud Control is responsible for grafting Cloud Kernel and Protocol. Following starts the initialization of cloud template in application. void APP_CldInit(void) { // user implement Cloud_Init(); } The Cloud Tx task and Cloud RX task will be initiated in Cloud_Init. The Cloud OTA task is optional. void Cloud_Init(void) { // create event group EG_Create(&g_tCloudEventGroup); // init tx task Cloud_TxTaskInit(); // init rx task Cloud_RxTaskInit(); // init ota http task #if (CLOUD_OTA_ENABLED == 1) Cloud_OtaTaskInit(); #endif } Several events can be handled in Cloud TX task, such establishing a connection with the cloud, disconnecting with the cloud, binding to the cloud, keeping alive with the cloud, waiting for the ack of the cloud and posting to cloud. How many events should be handled is depends on the features of the cloud to port. For example, the cloud establish event in the cloud template example. The Cloud TX task will receive cloud events, and execute the correspnding handlers found in event table g_tCloudTxEvtHandlerTbl . These handlers are responsible for executing cloud events through calling Protocol API. These handlers are located at Cloud Control. static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; Cloud_EstablishHandler (Cloud Control) can handle to establish connection with the cloud. The developer can call Protocol API to achieve cloud connection in Cloud_EstablishHandler . void Cloud_EstablishHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. establish connection // 2. determine the connect status // if connect success - set connection status as online // Cloud_OnlineStatusSet(true); // if connect fail // error handle - call retry connection timer // osTimerStart(g_tCloudConnectRetryTimer, ConnRetryDuration); // 3. if connect success, start keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Cloud_DisconnectHandler (Cloud Control) can handle to dsiconnect the cloud. The developer can call Protocol API to achieve cloud disconnection in Cloud_DisconnectHandler . void Cloud_DisconnectHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. close connection // 2. determine the disconnect result and change the connection status // if disconnect success - set connection status as offline // Cloud_OnlineStatusSet(false); // if disconnect fail // error handle // 3. if disconnect success, stop keep alive timer // Cloud_TimerStop(CLOUD_TMR_KEEP_ALIVE); } Cloud_BindingHandler (Cloud Control) can handle to bind the cloud. The developer can call Protocol API to achieve cloud binding in Cloud_BindingHandler . void Cloud_BindingHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. binding process } Cloud_KeepAliveHandler (Cloud Control) can handle to keep alive with the cloud. The developer can call Protocol API to achieve keeping alive with the cloud in Cloud_KeepAliveHandler . void Cloud_KeepAliveHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post keep alive data // 2. restart keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Cloud_AckHandler (Cloud Control) can handle to post ack to the cloud. The developer can call Protocol API to achieve to post ack to the cloud in Cloud_AckHandler . void Cloud_AckHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post ack data } Cloud_PostHandler (Cloud Control) can handle to post data to the cloud. The developer can call Protocol API to achieve to post data to the cloud in Cloud_PostHandler . void Cloud_PostHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) // 1. create your own scenario to backup data by using RingBuf (Cloud_RingBuf___) // 2. construct data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 3. post data // 4. send event CLOUD_EVT_TYPE_POST_BACKUP if RingBuf not empty #else // 1. construct income data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 2. post data #endif /* CLOUD_TX_DATA_BACKUP_ENABLED */ } Please refer to OTA ( \"OTA via WI-FI\" ) about CLOUD OTA. How To... How to port public/private cloud that utilizes Cloud Template The developer can copy the folder quick_dev\\app_ref\\cloud\\cloud_template to quick_dev\\app_ref\\cloud that copied folder could rename my_cloud to execute cloud process. There are two important files cloud_kernel.c (Cloud Kernel) & cloud_ctrl.c (Cloud Control). Cloud Kernel is responsible for receiving cloud events and data, then passing to these event's handlers. These handlers are located at Cloud Control. In cloud_kernel.c (Cloud Kernel), there are two components that are Cloud_TxTaskHandler (Cloud TX) and Cloud_RxTaskHandler (Cloud RX). Cloud TX process Cloud_TxTaskHandler is based on the cloud kernel event table g_tCloudTxEvtHandlerTbl . Some important events that are CLOUD_EVT_TYPE_ESTABLISH (establish connection with the cloud), CLOUD_EVT_TYPE_DISCONNECT (disconnect to the cloud), CLOUD_EVT_TYPE_KEEP_ALIVE (keep alive with the cloud), CLOUD_EVT_TYPE_ACK (response ack to the cloud) and CLOUD_EVT_TYPE_POST (post data to the cloud). There are the corresponding handlers (Cloud Control) to handle these events and pass to protocol to execute cloud kernel event. // cloud kernel event table static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; For example, if wnating to post datas to the cloud (TCP Cloud), the developer send post events and data from application to Cloud Kernel (Cloud TX task). Cloud TX task could gets these event and data to pass the corresponding handler Cloud_PostHandler . Cloud_PostHandler would construct data and pass data to Cloud_PostData . void Cloud_PostData(uint8_t *pu8Data, uint32_t u32DataLen) { int32_t i32Ret = 0; Opl_Wifi_Skip_Dtim_Set(g_u16CloudTcpSkipDtimId, false); osSemaphoreWait(g_tCloudSemaphoreId, osWaitForever); if(g_i32TcpTxId != g_i32TcpHdlId) { g_i32TcpTxId = g_i32TcpHdlId; } osSemaphoreRelease(g_tCloudSemaphoreId); i32Ret = TCP_Send(g_ptrCloudTcpHdlId, (const char *)pu8Data, u32DataLen, TCP_TX_POST_TIMEOUT); if(i32Ret <= 0) { OPL_LOG_ERRO(CLOUD, \"post fail (ret %d)\", i32Ret); osSemaphoreWait(g_tCloudSemaphoreId, osWaitForever); if(((uintptr_t)-1 != g_ptrCloudTcpHdlId) && (g_i32TcpHdlId == g_i32TcpTxId) && (true == Cloud_OnlineStatusGet())) { uint8_t u8ReConnect = true; Cloud_MsgSend(CLOUD_EVT_TYPE_DISCONNECT, &u8ReConnect, sizeof(u8ReConnect)); g_ptrCloudTcpHdlId = (uintptr_t)-1; g_i32TcpHdlId = -1; g_i32TcpTxId = -1; } osSemaphoreRelease(g_tCloudSemaphoreId); } OPL_LOG_INFO(CLOUD, \"post: %s (%d)\", pu8Data, u32DataLen); Opl_Wifi_Skip_Dtim_Set(g_u16CloudTcpSkipDtimId, true); } Cloud_PostData call TCP_Send (Cloud Control) to send data to send (TCP Protocol). int TCP_Send(uintptr_t fd, const char *buf, uint32_t len, uint32_t timeout_ms) { int ret; uint32_t len_sent; int net_err = 0; struct timeval timeout; timeout.tv_sec = timeout_ms/1000; timeout.tv_usec = (timeout_ms - (timeout.tv_sec * 1000)) * 1000; if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout)) < 0) { OPL_LOG_WARN(TCP, \"failed to set socket sending timeout\"); net_err = -2; return net_err; } ret = send(fd, buf, len, 0); if (ret > 0) { len_sent += ret; } else if (0 == ret) { OPL_LOG_WARN(TCP, \"no data to send\"); } else { OPL_LOG_ERRO(TCP, \"send data fail fd: fd[%d] ret[%d] %s\", fd, ret, strerror(errno)); net_err = 1; } if (net_err) { return -1; } else { return len_sent; } } Cloud RX process In cloud_kernel.c (Cloud Kernel), Cloud RX execute in Cloud_ReceiveHandler . Cloud_ReceiveHandler would call TCP_Recv (Cloud Control) to receive data from protocol. For example, if receiving data from the cloud (TCP CLOUD), the developer could use TCP_Recv (Cloud Control) call select (TCP protocol) to receive data and pass to Cloud_ReceiveHandler (Cloud Kernel). nt TCP_Recv(uintptr_t fd, char *buf, uint32_t len, uint32_t timeout_ms) { int ret, err_code; uint32_t len_recv; fd_set sets; struct timeval timeout; len_recv = 0; err_code = 0; FD_ZERO(&sets); FD_SET(fd, &sets); timeout.tv_sec = timeout_ms/1000; timeout.tv_usec = (timeout_ms - (timeout.tv_sec * 1000)) * 1000; ret = select(fd + 1, &sets, NULL, NULL, &timeout); if (ret > 0) { if (FD_ISSET(fd, &sets)) { ret = recv(fd, buf, len, 0); if (ret > 0) { len_recv += ret; } else if (0 == ret) { OPL_LOG_DEBG(TCP, \"connection is closed\"); err_code = -1; } else { OPL_LOG_ERRO(TCP, \"recv data fail: fd[%d] ret[%d] %s\", fd, ret, strerror(errno)); err_code = -2; } } } else if (0 == ret) { // printf(\"select-recv return 0\\n\"); //select timeout, nothing to do } else { //if (EINTR == errno) { // continue; //} OPL_LOG_ERRO(TCP, \"select-recv fail: fd[%d] ret[%d] %s\", fd, ret, strerror(errno)); err_code = -2; } /* priority to return data bytes if any data be received from TCP connection. */ /* It will get error code on next calling */ return (0 != len_recv) ? len_recv : err_code; }","title":"Cloud"},{"location":"application-guide/cloud/#cloud","text":"","title":"Cloud"},{"location":"application-guide/cloud/#cloud-template","text":"Cloud Template is a template architecture that help developer to integrate the device with the public/private cloud service and achieve the low power consumption and short latency purpose. There two components in Cloud Template, the Cloud Kernel and Cloud Control. Three tasks will be created in Cloud Kernel, they are Cloud TX task, Cloud RX task, and Cloud OTA task. Cloud Control is responsible for grafting Cloud Kernel and Protocol. Following starts the initialization of cloud template in application. void APP_CldInit(void) { // user implement Cloud_Init(); } The Cloud Tx task and Cloud RX task will be initiated in Cloud_Init. The Cloud OTA task is optional. void Cloud_Init(void) { // create event group EG_Create(&g_tCloudEventGroup); // init tx task Cloud_TxTaskInit(); // init rx task Cloud_RxTaskInit(); // init ota http task #if (CLOUD_OTA_ENABLED == 1) Cloud_OtaTaskInit(); #endif } Several events can be handled in Cloud TX task, such establishing a connection with the cloud, disconnecting with the cloud, binding to the cloud, keeping alive with the cloud, waiting for the ack of the cloud and posting to cloud. How many events should be handled is depends on the features of the cloud to port. For example, the cloud establish event in the cloud template example. The Cloud TX task will receive cloud events, and execute the correspnding handlers found in event table g_tCloudTxEvtHandlerTbl . These handlers are responsible for executing cloud events through calling Protocol API. These handlers are located at Cloud Control. static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; Cloud_EstablishHandler (Cloud Control) can handle to establish connection with the cloud. The developer can call Protocol API to achieve cloud connection in Cloud_EstablishHandler . void Cloud_EstablishHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. establish connection // 2. determine the connect status // if connect success - set connection status as online // Cloud_OnlineStatusSet(true); // if connect fail // error handle - call retry connection timer // osTimerStart(g_tCloudConnectRetryTimer, ConnRetryDuration); // 3. if connect success, start keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Cloud_DisconnectHandler (Cloud Control) can handle to dsiconnect the cloud. The developer can call Protocol API to achieve cloud disconnection in Cloud_DisconnectHandler . void Cloud_DisconnectHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // user implement // 1. close connection // 2. determine the disconnect result and change the connection status // if disconnect success - set connection status as offline // Cloud_OnlineStatusSet(false); // if disconnect fail // error handle // 3. if disconnect success, stop keep alive timer // Cloud_TimerStop(CLOUD_TMR_KEEP_ALIVE); } Cloud_BindingHandler (Cloud Control) can handle to bind the cloud. The developer can call Protocol API to achieve cloud binding in Cloud_BindingHandler . void Cloud_BindingHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. binding process } Cloud_KeepAliveHandler (Cloud Control) can handle to keep alive with the cloud. The developer can call Protocol API to achieve keeping alive with the cloud in Cloud_KeepAliveHandler . void Cloud_KeepAliveHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post keep alive data // 2. restart keep alive timer // Cloud_TimerStart(CLOUD_TMR_KEEP_ALIVE, CLOUD_KEEP_ALIVE_TIME); } Cloud_AckHandler (Cloud Control) can handle to post ack to the cloud. The developer can call Protocol API to achieve to post ack to the cloud in Cloud_AckHandler . void Cloud_AckHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement // 1. post ack data } Cloud_PostHandler (Cloud Control) can handle to post data to the cloud. The developer can call Protocol API to achieve to post data to the cloud in Cloud_PostHandler . void Cloud_PostHandler(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { // check connection first if(false == Cloud_OnlineStatusGet()) { OPL_LOG_INFO(CLOUD, \"Cloud disconnected\"); } // user implement #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) // 1. create your own scenario to backup data by using RingBuf (Cloud_RingBuf___) // 2. construct data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 3. post data // 4. send event CLOUD_EVT_TYPE_POST_BACKUP if RingBuf not empty #else // 1. construct income data for post (if required) // Cloud_DataConstruct(pData, u32DataLen); // 2. post data #endif /* CLOUD_TX_DATA_BACKUP_ENABLED */ } Please refer to OTA ( \"OTA via WI-FI\" ) about CLOUD OTA.","title":"Cloud Template"},{"location":"application-guide/cloud/#how-to","text":"","title":"How To..."},{"location":"application-guide/cloud/#how-to-port-publicprivate-cloud-that-utilizes-cloud-template","text":"The developer can copy the folder quick_dev\\app_ref\\cloud\\cloud_template to quick_dev\\app_ref\\cloud that copied folder could rename my_cloud to execute cloud process. There are two important files cloud_kernel.c (Cloud Kernel) & cloud_ctrl.c (Cloud Control). Cloud Kernel is responsible for receiving cloud events and data, then passing to these event's handlers. These handlers are located at Cloud Control. In cloud_kernel.c (Cloud Kernel), there are two components that are Cloud_TxTaskHandler (Cloud TX) and Cloud_RxTaskHandler (Cloud RX). Cloud TX process Cloud_TxTaskHandler is based on the cloud kernel event table g_tCloudTxEvtHandlerTbl . Some important events that are CLOUD_EVT_TYPE_ESTABLISH (establish connection with the cloud), CLOUD_EVT_TYPE_DISCONNECT (disconnect to the cloud), CLOUD_EVT_TYPE_KEEP_ALIVE (keep alive with the cloud), CLOUD_EVT_TYPE_ACK (response ack to the cloud) and CLOUD_EVT_TYPE_POST (post data to the cloud). There are the corresponding handlers (Cloud Control) to handle these events and pass to protocol to execute cloud kernel event. // cloud kernel event table static T_CloudTxEvtHandlerTbl g_tCloudTxEvtHandlerTbl[] = { {CLOUD_EVT_TYPE_INIT, Cloud_InitHandler}, {CLOUD_EVT_TYPE_ESTABLISH, Cloud_EstablishHandler}, {CLOUD_EVT_TYPE_DISCONNECT, Cloud_DisconnectHandler}, {CLOUD_EVT_TYPE_TIMEOUT, Cloud_TimeoutHandler}, {CLOUD_EVT_TYPE_BINDING, Cloud_BindingHandler}, {CLOUD_EVT_TYPE_KEEP_ALIVE, Cloud_KeepAliveHandler}, {CLOUD_EVT_TYPE_ACK, Cloud_AckHandler}, {CLOUD_EVT_TYPE_POST, Cloud_PostHandler}, #if (CLOUD_TX_DATA_BACKUP_ENABLED == 1) {CLOUD_EVT_TYPE_POST_BACKUP, Cloud_PostBackupHandler}, #endif }; For example, if wnating to post datas to the cloud (TCP Cloud), the developer send post events and data from application to Cloud Kernel (Cloud TX task). Cloud TX task could gets these event and data to pass the corresponding handler Cloud_PostHandler . Cloud_PostHandler would construct data and pass data to Cloud_PostData . void Cloud_PostData(uint8_t *pu8Data, uint32_t u32DataLen) { int32_t i32Ret = 0; Opl_Wifi_Skip_Dtim_Set(g_u16CloudTcpSkipDtimId, false); osSemaphoreWait(g_tCloudSemaphoreId, osWaitForever); if(g_i32TcpTxId != g_i32TcpHdlId) { g_i32TcpTxId = g_i32TcpHdlId; } osSemaphoreRelease(g_tCloudSemaphoreId); i32Ret = TCP_Send(g_ptrCloudTcpHdlId, (const char *)pu8Data, u32DataLen, TCP_TX_POST_TIMEOUT); if(i32Ret <= 0) { OPL_LOG_ERRO(CLOUD, \"post fail (ret %d)\", i32Ret); osSemaphoreWait(g_tCloudSemaphoreId, osWaitForever); if(((uintptr_t)-1 != g_ptrCloudTcpHdlId) && (g_i32TcpHdlId == g_i32TcpTxId) && (true == Cloud_OnlineStatusGet())) { uint8_t u8ReConnect = true; Cloud_MsgSend(CLOUD_EVT_TYPE_DISCONNECT, &u8ReConnect, sizeof(u8ReConnect)); g_ptrCloudTcpHdlId = (uintptr_t)-1; g_i32TcpHdlId = -1; g_i32TcpTxId = -1; } osSemaphoreRelease(g_tCloudSemaphoreId); } OPL_LOG_INFO(CLOUD, \"post: %s (%d)\", pu8Data, u32DataLen); Opl_Wifi_Skip_Dtim_Set(g_u16CloudTcpSkipDtimId, true); } Cloud_PostData call TCP_Send (Cloud Control) to send data to send (TCP Protocol). int TCP_Send(uintptr_t fd, const char *buf, uint32_t len, uint32_t timeout_ms) { int ret; uint32_t len_sent; int net_err = 0; struct timeval timeout; timeout.tv_sec = timeout_ms/1000; timeout.tv_usec = (timeout_ms - (timeout.tv_sec * 1000)) * 1000; if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout)) < 0) { OPL_LOG_WARN(TCP, \"failed to set socket sending timeout\"); net_err = -2; return net_err; } ret = send(fd, buf, len, 0); if (ret > 0) { len_sent += ret; } else if (0 == ret) { OPL_LOG_WARN(TCP, \"no data to send\"); } else { OPL_LOG_ERRO(TCP, \"send data fail fd: fd[%d] ret[%d] %s\", fd, ret, strerror(errno)); net_err = 1; } if (net_err) { return -1; } else { return len_sent; } } Cloud RX process In cloud_kernel.c (Cloud Kernel), Cloud RX execute in Cloud_ReceiveHandler . Cloud_ReceiveHandler would call TCP_Recv (Cloud Control) to receive data from protocol. For example, if receiving data from the cloud (TCP CLOUD), the developer could use TCP_Recv (Cloud Control) call select (TCP protocol) to receive data and pass to Cloud_ReceiveHandler (Cloud Kernel). nt TCP_Recv(uintptr_t fd, char *buf, uint32_t len, uint32_t timeout_ms) { int ret, err_code; uint32_t len_recv; fd_set sets; struct timeval timeout; len_recv = 0; err_code = 0; FD_ZERO(&sets); FD_SET(fd, &sets); timeout.tv_sec = timeout_ms/1000; timeout.tv_usec = (timeout_ms - (timeout.tv_sec * 1000)) * 1000; ret = select(fd + 1, &sets, NULL, NULL, &timeout); if (ret > 0) { if (FD_ISSET(fd, &sets)) { ret = recv(fd, buf, len, 0); if (ret > 0) { len_recv += ret; } else if (0 == ret) { OPL_LOG_DEBG(TCP, \"connection is closed\"); err_code = -1; } else { OPL_LOG_ERRO(TCP, \"recv data fail: fd[%d] ret[%d] %s\", fd, ret, strerror(errno)); err_code = -2; } } } else if (0 == ret) { // printf(\"select-recv return 0\\n\"); //select timeout, nothing to do } else { //if (EINTR == errno) { // continue; //} OPL_LOG_ERRO(TCP, \"select-recv fail: fd[%d] ret[%d] %s\", fd, ret, strerror(errno)); err_code = -2; } /* priority to return data bytes if any data be received from TCP connection. */ /* It will get error code on next calling */ return (0 != len_recv) ? len_recv : err_code; }","title":"How to port public/private cloud that utilizes Cloud Template"},{"location":"application-guide/log_config/","text":"Log Configuration The Log Configuration quick_dev\\common\\log\\log.h is the configuration that package one layer on bottom layer tracer_log in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . The log configuration can help developer to trace and debug in application, the log can divide into four types that are debug, information, warnnimg and error. The developer can switch the log level that they want to see according to their needs. To enter tracer level <task_index> <task_level:hex> could turn on tracer level in debug console. If wanting to trace log with Log Configration, the developer could use tracer_def_level_set() to set trcae log. The developer can refer to the following examples static void Main_AppInit_patch(void) { sys_cfg_clk_set(SYS_CFG_CLK_RATE); // set default tracer level in user app type to INFO, WARN, ERRO (DEBG not open) tracer_def_level_set(TRACER_TASK_TYPE_APP, 0x06); APP_MainInit(); } The argument TRACER_TASK_TYPE_APP is a trace type that include TRACER_TASK_TYPE_INTERNAL (bottom layer) and TRACER_TASK_TYPE_APP (application) defined in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . typedef enum { TRACER_TASK_TYPE_INTERNAL = 0, TRACER_TASK_TYPE_APP, TRACER_TASK_TYPE_MAX } T_TracerTaskType; The other argument 0x06 is trace level that developer want to trace. There are the following trace level in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . #define LOG_HIGH_LEVEL 0x04 #define LOG_MED_LEVEL 0x02 #define LOG_LOW_LEVEL 0x01 #define LOG_NONE_LEVEL 0x00 #define LOG_ALL_LEVEL (LOG_HIGH_LEVEL | LOG_MED_LEVEL | LOG_LOW_LEVEL) The argument 0x06 means trace log level turn on LOG_HIGH_LEVEL and LOG_MED_LEVEL but LOG_LOW_LEVEL is turn off. Log Configuration has the following log levels : Debug ( LOG_LOW_LEVEL ) #define OPL_LOG_DEBG(module, ...) \\ { \\ tracer_log(LOG_LOW_LEVEL, \"\\x1B[0m[D][%s]\", #module); \\ tracer_log(LOG_LOW_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_LOW_LEVEL, \"\\r\\n\"); \\ } Info ( LOG_MED_LEVEL ) #define OPL_LOG_INFO(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m[I][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\r\\n\"); \\ } Warn ( LOG_MED_LEVEL ) #define OPL_LOG_WARN(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[33m[W][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } Error ( LOG_HIGH_LEVEL ) #define OPL_LOG_ERRO(module, ...) \\ { \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[31m[E][%s]\", #module); \\ tracer_log(LOG_HIGH_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } The developer could set what module in the argument module . Log configuration can also be set according to the log of which module (e.g. BLE Manager log)the developer wants to see in qd_module.h . Module log enable set (1) (e.g. BM_LOG_ENABLED) #ifndef BM_LOG_ENABLED #define BM_LOG_ENABLED (1) #endif","title":"Log Configuration"},{"location":"application-guide/log_config/#log-configuration","text":"The Log Configuration quick_dev\\common\\log\\log.h is the configuration that package one layer on bottom layer tracer_log in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . The log configuration can help developer to trace and debug in application, the log can divide into four types that are debug, information, warnnimg and error. The developer can switch the log level that they want to see according to their needs. To enter tracer level <task_index> <task_level:hex> could turn on tracer level in debug console. If wanting to trace log with Log Configration, the developer could use tracer_def_level_set() to set trcae log. The developer can refer to the following examples static void Main_AppInit_patch(void) { sys_cfg_clk_set(SYS_CFG_CLK_RATE); // set default tracer level in user app type to INFO, WARN, ERRO (DEBG not open) tracer_def_level_set(TRACER_TASK_TYPE_APP, 0x06); APP_MainInit(); } The argument TRACER_TASK_TYPE_APP is a trace type that include TRACER_TASK_TYPE_INTERNAL (bottom layer) and TRACER_TASK_TYPE_APP (application) defined in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . typedef enum { TRACER_TASK_TYPE_INTERNAL = 0, TRACER_TASK_TYPE_APP, TRACER_TASK_TYPE_MAX } T_TracerTaskType; The other argument 0x06 is trace level that developer want to trace. There are the following trace level in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . #define LOG_HIGH_LEVEL 0x04 #define LOG_MED_LEVEL 0x02 #define LOG_LOW_LEVEL 0x01 #define LOG_NONE_LEVEL 0x00 #define LOG_ALL_LEVEL (LOG_HIGH_LEVEL | LOG_MED_LEVEL | LOG_LOW_LEVEL) The argument 0x06 means trace log level turn on LOG_HIGH_LEVEL and LOG_MED_LEVEL but LOG_LOW_LEVEL is turn off. Log Configuration has the following log levels : Debug ( LOG_LOW_LEVEL ) #define OPL_LOG_DEBG(module, ...) \\ { \\ tracer_log(LOG_LOW_LEVEL, \"\\x1B[0m[D][%s]\", #module); \\ tracer_log(LOG_LOW_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_LOW_LEVEL, \"\\r\\n\"); \\ } Info ( LOG_MED_LEVEL ) #define OPL_LOG_INFO(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m[I][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\r\\n\"); \\ } Warn ( LOG_MED_LEVEL ) #define OPL_LOG_WARN(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[33m[W][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } Error ( LOG_HIGH_LEVEL ) #define OPL_LOG_ERRO(module, ...) \\ { \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[31m[E][%s]\", #module); \\ tracer_log(LOG_HIGH_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } The developer could set what module in the argument module . Log configuration can also be set according to the log of which module (e.g. BLE Manager log)the developer wants to see in qd_module.h . Module log enable set (1) (e.g. BM_LOG_ENABLED) #ifndef BM_LOG_ENABLED #define BM_LOG_ENABLED (1) #endif","title":"Log Configuration"},{"location":"application-guide/mp/","text":"MP","title":"MP"},{"location":"application-guide/mp/#mp","text":"","title":"MP"},{"location":"application-guide/ota/","text":"OTA Over-The-Air (OTA) is a procedure to update the firmware without the use of physical wires. OTA is responsible for the flash procedure. The OTA data can be received from phone app via BLE or cloud via Wi-Fi connection. When a product is ready and released in the field, OTA can be used to upload new firmware that brings new features. OTA via BLE \"OTA via BLE\" can complete firmware update via Bluetooth from the mobile phone APP (e.g. \"Opulinks\"). First, send an \"OTA request\" message to the device from the mobile phone. After receiving, BLE Application will parse the \"OTA request\" message and request OTA Manager to execute OTA process. The developer can call BLE Application API OPL_DataRecvHandler to pass the \"OTA request\" message to BLE Application when this message enters User Application from BLE Manager. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } There are four stage in OTA procedure. #if (OTA_ENABLED == 1) {OPL_DATA_REQ_OTA_VERSION, OPL_DataProtocol_OtaVersion}, {OPL_DATA_REQ_OTA_UPGRADE, OPL_DataProtocol_OtaUpgrade}, {OPL_DATA_REQ_OTA_RAW, OPL_DataProtocol_OtaRaw}, {OPL_DATA_REQ_OTA_END, OPL_DataProtocol_OtaEnd}, #endif To start OTA, the BLE Application will first receive an event OPL_DATA_REQ_OTA_VERSION and call OTA Manager API OTA_CurrentVersionGet to get current OTA firmware version. static void OPL_DataProtocol_OtaVersion(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_VERSION\"); uint16_t pid; uint16_t cid; uint16_t fid; T_OplErr tEvtRst = OTA_CurrentVersionGet(&pid, &cid, &fid); if (OPL_OK != tEvtRst) OPL_OtaSendVersionRsp(OPL_DATA_OTA_ERR_HW_FAILURE, 0, 0, 0); else OPL_OtaSendVersionRsp(OPL_DATA_OTA_SUCCESS, pid, cid, fid); } If checking OTA firmware version OK, the device will receive OPL_DATA_REQ_OTA_UPGRADE and call OTA Manager API OTA_UpgradeBegin to start to upgrade firmware. static void OPL_DataProtocol_OtaUpgrade(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_UPGRADE\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_UpgradeBegin(&g_u16OtaSeqId, ota_hdr, OPL_OtaTimeoutIndCb); if(OPL_OK == tEvtRst) { OPL_OtaSendUpgradeRsp(OPL_DATA_OTA_SUCCESS); gTheOta = ota; } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_HW_FAILURE, TRUE); } } If starting OTA upgrading OK, the device will receive OPL_DATA_REQ_OTA_RAW and call OTA Manager API OTA_WriteData to start raw data of new firmware from mobile phone. static void OPL_DataProtocol_OtaRaw(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_RAW\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_WriteData(g_u16OtaSeqId, ota->buf, 256); return; } If rawing data successfully, the device will receive OPL_DATA_REQ_OTA_END and call OTA Manager API OTA_UpgradeFinish to finish OTA process. static void OPL_DataProtocol_OtaEnd(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_END\"); T_OplOtaData *ota = gTheOta; uint8_t status = data[0]; if(OPL_OK == OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_SendEndRsp(OPL_DATA_OTA_SUCCESS, TRUE); } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_CHECKSUM, TRUE); } return; } OTA via WI-FI \"OTA via WI-FI\" update mechanism helps users to easily and securely update the new firmware on their device through Wi-Fi. To enable WI-FI OTA, the developer should enable CLOUD_OTA_ENABLED in cloud_config.h . // WI-FI ota enable (OTA_ENABLE and OTA_Init() must required) #ifndef CLOUD_OTA_ENABLED #define CLOUD_OTA_ENABLED (1) #endif cloud_ota_http.c (Cloud OTA) is responsible for retrieving OTA data from cloud. In Cloud_OtaTaskHandler , the OTA event CLOUD_OTA_EVT_TYPE_DOWNLOAD will be received and then it applies Cloud_OtaHttpDownload to complete OTA process. void Cloud_OtaTaskHandler(void *args) { osEvent tEvent; T_CloudDataMsg *ptCloudOtaMsg; for(;;) { // wait event tEvent = osMessageGet(g_tCloudOtaQueueId, osWaitForever); if(tEvent.status == osEventMessage) { ptCloudOtaMsg = (T_CloudDataMsg *)tEvent.value.p; switch(ptCloudOtaMsg->u32EventId) { case CLOUD_OTA_EVT_TYPE_DOWNLOAD: { int32_t i32Ret = Cloud_OtaHttpDownload((char *)ptCloudOtaMsg->u8aData, (int)ptCloudOtaMsg->u32DataLen); break; } } } } } Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process. \"OTA via WI-FI\" process include connecting to http server, getting current OTA version, retrieving raw data of new firmware from cloud, and finishing OTA process via OTA Manager. int32_t Cloud_OtaHttpDownload(char *url, int len) { char get_url[CLOUD_OTA_HTTP_URL_LEN]; char *buf; int8_t i8Ret = HTTPCLIENT_ERROR_CONN; uint32_t u16UrlLen = strlen(url); uint16_t u16Pid, u16Cid, u16Fid; uint8_t u8RetryCount = 0; // connect to http server do { i8Ret = httpclient_connect(&g_tCloudOtaHttpClient, get_url); if(!i8Ret) { OPL_LOG_INFO(CLOUD, \"Connect to http server\"); break; } else { osDelay(1000); u8RetryCount ++; OPL_LOG_WARN(CLOUD, \"Connect to http server fail, retry count (%d)\", u8RetryCount); } } while(u8RetryCount < CLOUD_OTA_HTTP_CONNECTION_RETRY_COUNT); // get current ota version OTA_CurrentVersionGet(&u16Pid, &u16Cid, &u16Fid); OPL_LOG_DEBG(CLOUD, \"pid=%d, cid=%d, fid=%d\", u16Pid, u16Cid, u16Fid); //raw data of new firmware from the cloud i8Ret = _Cloud_OtaHttpRetrieveGet(get_url, buf, CLOUD_OTA_HTTP_DATA_LEN); if(0 > i8Ret) { if(OPL_OK != OTA_UpgradeGiveUp(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA give up fail\"); } } else { //complete OTA if(OPL_OK != OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA finish fail\"); } } OPL_LOG_INFO(CLOUD, \"download result = %d\", i8Ret); // close http connection httpclient_close(&g_tCloudOtaHttpClient); free(buf); buf = NULL; return i8Ret; } How To... How to execute OTA via WI-FI in a single task Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process Apply httpclient_connect to connect http server Apply OTA_CurrentVersionGet Get current OTA firmware version via OTA Manager Apply _Cloud_OtaHttpRetrieveGet to retrieve raw data of new firmware from the cloud If retrieving sucessfully, apply OTA_UpgradeFinish to complete OTA via OTA Manager Apply httpclient_close to close http connection","title":"OTA"},{"location":"application-guide/ota/#ota","text":"Over-The-Air (OTA) is a procedure to update the firmware without the use of physical wires. OTA is responsible for the flash procedure. The OTA data can be received from phone app via BLE or cloud via Wi-Fi connection. When a product is ready and released in the field, OTA can be used to upload new firmware that brings new features.","title":"OTA"},{"location":"application-guide/ota/#ota-via-ble","text":"\"OTA via BLE\" can complete firmware update via Bluetooth from the mobile phone APP (e.g. \"Opulinks\"). First, send an \"OTA request\" message to the device from the mobile phone. After receiving, BLE Application will parse the \"OTA request\" message and request OTA Manager to execute OTA process. The developer can call BLE Application API OPL_DataRecvHandler to pass the \"OTA request\" message to BLE Application when this message enters User Application from BLE Manager. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } There are four stage in OTA procedure. #if (OTA_ENABLED == 1) {OPL_DATA_REQ_OTA_VERSION, OPL_DataProtocol_OtaVersion}, {OPL_DATA_REQ_OTA_UPGRADE, OPL_DataProtocol_OtaUpgrade}, {OPL_DATA_REQ_OTA_RAW, OPL_DataProtocol_OtaRaw}, {OPL_DATA_REQ_OTA_END, OPL_DataProtocol_OtaEnd}, #endif To start OTA, the BLE Application will first receive an event OPL_DATA_REQ_OTA_VERSION and call OTA Manager API OTA_CurrentVersionGet to get current OTA firmware version. static void OPL_DataProtocol_OtaVersion(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_VERSION\"); uint16_t pid; uint16_t cid; uint16_t fid; T_OplErr tEvtRst = OTA_CurrentVersionGet(&pid, &cid, &fid); if (OPL_OK != tEvtRst) OPL_OtaSendVersionRsp(OPL_DATA_OTA_ERR_HW_FAILURE, 0, 0, 0); else OPL_OtaSendVersionRsp(OPL_DATA_OTA_SUCCESS, pid, cid, fid); } If checking OTA firmware version OK, the device will receive OPL_DATA_REQ_OTA_UPGRADE and call OTA Manager API OTA_UpgradeBegin to start to upgrade firmware. static void OPL_DataProtocol_OtaUpgrade(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_UPGRADE\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_UpgradeBegin(&g_u16OtaSeqId, ota_hdr, OPL_OtaTimeoutIndCb); if(OPL_OK == tEvtRst) { OPL_OtaSendUpgradeRsp(OPL_DATA_OTA_SUCCESS); gTheOta = ota; } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_HW_FAILURE, TRUE); } } If starting OTA upgrading OK, the device will receive OPL_DATA_REQ_OTA_RAW and call OTA Manager API OTA_WriteData to start raw data of new firmware from mobile phone. static void OPL_DataProtocol_OtaRaw(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_RAW\"); T_OplOtaData *ota = gTheOta; T_OplErr tEvtRst = OPL_OK; tEvtRst = OTA_WriteData(g_u16OtaSeqId, ota->buf, 256); return; } If rawing data successfully, the device will receive OPL_DATA_REQ_OTA_END and call OTA Manager API OTA_UpgradeFinish to finish OTA process. static void OPL_DataProtocol_OtaEnd(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_OTA_END\"); T_OplOtaData *ota = gTheOta; uint8_t status = data[0]; if(OPL_OK == OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_SendEndRsp(OPL_DATA_OTA_SUCCESS, TRUE); } else { OPL_SendEndRsp(OPL_DATA_OTA_ERR_CHECKSUM, TRUE); } return; }","title":"OTA via BLE"},{"location":"application-guide/ota/#ota-via-wi-fi","text":"\"OTA via WI-FI\" update mechanism helps users to easily and securely update the new firmware on their device through Wi-Fi. To enable WI-FI OTA, the developer should enable CLOUD_OTA_ENABLED in cloud_config.h . // WI-FI ota enable (OTA_ENABLE and OTA_Init() must required) #ifndef CLOUD_OTA_ENABLED #define CLOUD_OTA_ENABLED (1) #endif cloud_ota_http.c (Cloud OTA) is responsible for retrieving OTA data from cloud. In Cloud_OtaTaskHandler , the OTA event CLOUD_OTA_EVT_TYPE_DOWNLOAD will be received and then it applies Cloud_OtaHttpDownload to complete OTA process. void Cloud_OtaTaskHandler(void *args) { osEvent tEvent; T_CloudDataMsg *ptCloudOtaMsg; for(;;) { // wait event tEvent = osMessageGet(g_tCloudOtaQueueId, osWaitForever); if(tEvent.status == osEventMessage) { ptCloudOtaMsg = (T_CloudDataMsg *)tEvent.value.p; switch(ptCloudOtaMsg->u32EventId) { case CLOUD_OTA_EVT_TYPE_DOWNLOAD: { int32_t i32Ret = Cloud_OtaHttpDownload((char *)ptCloudOtaMsg->u8aData, (int)ptCloudOtaMsg->u32DataLen); break; } } } } } Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process. \"OTA via WI-FI\" process include connecting to http server, getting current OTA version, retrieving raw data of new firmware from cloud, and finishing OTA process via OTA Manager. int32_t Cloud_OtaHttpDownload(char *url, int len) { char get_url[CLOUD_OTA_HTTP_URL_LEN]; char *buf; int8_t i8Ret = HTTPCLIENT_ERROR_CONN; uint32_t u16UrlLen = strlen(url); uint16_t u16Pid, u16Cid, u16Fid; uint8_t u8RetryCount = 0; // connect to http server do { i8Ret = httpclient_connect(&g_tCloudOtaHttpClient, get_url); if(!i8Ret) { OPL_LOG_INFO(CLOUD, \"Connect to http server\"); break; } else { osDelay(1000); u8RetryCount ++; OPL_LOG_WARN(CLOUD, \"Connect to http server fail, retry count (%d)\", u8RetryCount); } } while(u8RetryCount < CLOUD_OTA_HTTP_CONNECTION_RETRY_COUNT); // get current ota version OTA_CurrentVersionGet(&u16Pid, &u16Cid, &u16Fid); OPL_LOG_DEBG(CLOUD, \"pid=%d, cid=%d, fid=%d\", u16Pid, u16Cid, u16Fid); //raw data of new firmware from the cloud i8Ret = _Cloud_OtaHttpRetrieveGet(get_url, buf, CLOUD_OTA_HTTP_DATA_LEN); if(0 > i8Ret) { if(OPL_OK != OTA_UpgradeGiveUp(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA give up fail\"); } } else { //complete OTA if(OPL_OK != OTA_UpgradeFinish(g_u16OtaSeqId)) { OPL_LOG_ERRO(CLOUD, \"OTA finish fail\"); } } OPL_LOG_INFO(CLOUD, \"download result = %d\", i8Ret); // close http connection httpclient_close(&g_tCloudOtaHttpClient); free(buf); buf = NULL; return i8Ret; }","title":"OTA via WI-FI"},{"location":"application-guide/ota/#how-to","text":"How to execute OTA via WI-FI in a single task Cloud_OtaHttpDownload is a single task to execute \"OTA via WI-FI\" process Apply httpclient_connect to connect http server Apply OTA_CurrentVersionGet Get current OTA firmware version via OTA Manager Apply _Cloud_OtaHttpRetrieveGet to retrieve raw data of new firmware from the cloud If retrieving sucessfully, apply OTA_UpgradeFinish to complete OTA via OTA Manager Apply httpclient_close to close http connection","title":"How To..."},{"location":"application-guide/project_config/","text":"Project Configuration There are two configuration concepts qd_config.h and qd_module.h in this topic. In qd_config, we help developers classify some system configurations, among which power save is the key point. We use the concept of modularity to include the configuration method in qd_module. About 'qd_config.h' OPL Chip ID check #if defined(OPL1000_A2) || defined(OPL1000_A3) #else #error \"no define chip id in global definition in 'Preprocessor Symbols'\" #endif The chip id should be defined in Keil project file. RF power setting configuration #ifndef RF_CFG_DEF_PWR_SET #define RF_CFG_DEF_PWR_SET (RF_PWR_LVL_A0) #endif System configuration Set Power save mode #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif There are three default types of SYS_CFG_PS_MODE that 0 means Low Power, 1 means Balance, 2 means Performance, else means user define if choosing user define. There are the following configurations that need to be manually configured by the developer if choosing else. Smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif Mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif Wi-Fi dtim period time #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif Auto-connect retry interval #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif About 'qd_module.h' The developer can choose to use the desired module in qd_module.h Network Manager module If wanting to use Network Manager module to implement Wi-Fi process, the developer could set NM_ENABLED (1). At the same time, the developer must set Wi-Fi Manager module on that set WM_ENABLED (1). #ifndef NM_ENABLED #define NM_ENABLED (1) #endif The developer could only use Wi-Fi Manager module to implement Wi-Fi process if the developer don't use Network Manager module. Set NM_ENABLED (0) and WM_ENABLED (1). Wi-Fi Manager module #ifndef WM_ENABLED #define WM_ENABLED (1) #endif BLE Manager module If wanting to use BLE Manager module, the developer sets BM_ENABLED (1). #ifndef BM_ENABLED #define BM_ENABLED (1) #endif Time stamp module If wanting to use Time stamp module, the developer sets TIME_STMP_ENABLED (1). #ifndef TIME_STMP_ENABLED #define TIME_STMP_ENABLED (1) #endif Finite state machine If using Wi-Fi Manager module and BLE manager module, the developer must use Finite state machine module that set FSM_ENABLED (1). #ifndef FSM_ENABLED #define FSM_ENABLED (1) #endif","title":"Project Configuration"},{"location":"application-guide/project_config/#project-configuration","text":"There are two configuration concepts qd_config.h and qd_module.h in this topic. In qd_config, we help developers classify some system configurations, among which power save is the key point. We use the concept of modularity to include the configuration method in qd_module.","title":"Project Configuration"},{"location":"application-guide/project_config/#about-qd_configh","text":"OPL Chip ID check #if defined(OPL1000_A2) || defined(OPL1000_A3) #else #error \"no define chip id in global definition in 'Preprocessor Symbols'\" #endif The chip id should be defined in Keil project file. RF power setting configuration #ifndef RF_CFG_DEF_PWR_SET #define RF_CFG_DEF_PWR_SET (RF_PWR_LVL_A0) #endif System configuration Set Power save mode #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif There are three default types of SYS_CFG_PS_MODE that 0 means Low Power, 1 means Balance, 2 means Performance, else means user define if choosing user define. There are the following configurations that need to be manually configured by the developer if choosing else. Smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif Mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif Wi-Fi dtim period time #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif Auto-connect retry interval #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif","title":"About 'qd_config.h'"},{"location":"application-guide/project_config/#about-qd_moduleh","text":"The developer can choose to use the desired module in qd_module.h Network Manager module If wanting to use Network Manager module to implement Wi-Fi process, the developer could set NM_ENABLED (1). At the same time, the developer must set Wi-Fi Manager module on that set WM_ENABLED (1). #ifndef NM_ENABLED #define NM_ENABLED (1) #endif The developer could only use Wi-Fi Manager module to implement Wi-Fi process if the developer don't use Network Manager module. Set NM_ENABLED (0) and WM_ENABLED (1). Wi-Fi Manager module #ifndef WM_ENABLED #define WM_ENABLED (1) #endif BLE Manager module If wanting to use BLE Manager module, the developer sets BM_ENABLED (1). #ifndef BM_ENABLED #define BM_ENABLED (1) #endif Time stamp module If wanting to use Time stamp module, the developer sets TIME_STMP_ENABLED (1). #ifndef TIME_STMP_ENABLED #define TIME_STMP_ENABLED (1) #endif Finite state machine If using Wi-Fi Manager module and BLE manager module, the developer must use Finite state machine module that set FSM_ENABLED (1). #ifndef FSM_ENABLED #define FSM_ENABLED (1) #endif","title":"About 'qd_module.h'"},{"location":"application-guide/wifi/","text":"WI-FI Descript of WI-FI manager & Network Manager & Auto-Connect Network Manager Network manager can handling wifi manager & auto-connect interactive behavior to let user only care about triggering WI-FI scan request and connect request. Info To see the usage example of Network Manager, can check in qd_app in examples\\start_up\\ folder. The network manager initiation will also initialize the wifi manager and auto-connect. It's not necessary to initiate again in application Initialize Before using the network manager, please follow below steps to initiate. Step 1. Enable network manager #define WM_ENABLED (1) #define NM_ENABLED (1) #define AC_ENABLED (1) The definition been defined in qd_config.h in sys_config folder. Warning WM_ENABLED and AC_ENABLED are both required if using network manager. (The AC_ENABLED definition will be force to set as true while NM_ENABLED been set.) Step 2. Add related files in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_NmUnsolicitedCallback(T_NmUslctdEvtType tEvtType, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to net_mngr_api.h switch(tEvtType) { case NM_USLCTD_EVT_NETWORK_UP: { // wifi connected & got ip event break; } case NM_USLCTD_EVT_NETWORK_DOWN: { // wifi disconnect event break; } case NM_USLCTD_EVT_NETWORK_RESET: { // wifi reset event break; } default: { // should not be here break; } } } void APP_NetInit(void) { // Network manager initialize (auto-connect enable) APP_NmInit(true, &APP_NmUnsolicitedCallback); // user implement } The first parameter of APP_NmInit() is to enable/disable auto-connect at started. If set as true - the auto-connect will directly be funtional in sequence. If set as false - the auto-connect won't active. Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it. Unsolicited callback & Indicate callback There're two types of callback function pointer can be assign to Network manager Unsolicited callback - Used for recving unsolicited events from network manager, will be called in network up (Wi-Fi connected & IP got)/ network down/ WI-FI reset. Info network up event represents to WI-FI connected and got dhcp ip Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to network manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in nm_mngr_api.h WI-FI Manager WI-FI manager provide a easy way to control WI-FI. Info Network manager runs base on WI-FI manager, so if using the network manager the WI-FI manager will be directly initiate at network manager initiation. Initialize Before using the WI-FI manager, please follow below steps to initiate. Step 1. Enable WI-FI manager #define WM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder. Step 2. Add related files in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_WmUnsolicitedCallback(T_WmUslctedEvtType tEvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to wifi_mngr_api.h switch(tEvtType) { case USLCTED_CB_EVT_WIFI_UP: { // wifi connected event break; } case USLCTED_CB_EVT_WIFI_DOWN: { // wifi disconnect event break; } case USLCTED_CB_EVT_WIFI_RESET: { // wifi reset event break; } case USLCTED_CB_EVT_GOT_IP: { // wifi got ip break; } } } void APP_WifiInitDoneIndCallback(T_OplErr tEvtRst) { APP_SendMessage(APP_EVT_WIFI_INIT_DONE, (uint8_t*)&tEvtRst, sizeof(T_OplErr)); } void APP_NetInit(void) { // register Wi-Fi unsolicited callback if(OPL_OK != Opl_Wifi_Uslctd_CB_Reg(APP_WmUnsolicitedCallback)) { OPL_LOG_ERRO(APP, \"Wi-Fi unsolicited callback regist fail\"); } // Wi-Fi manager initialize Opl_Wifi_Init_Req(APP_WifiInitDoneIndCallback); // user implement } Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it. Unsolicited callback & Indicate callback There're two types of callback function pointer can be assign to WI-FI manager Unsolicited callback - Used for recving unsolicited events from WI-FI, will happens in WI-FI connected/ disconnected/ reset/ got ip. Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to WI-FI manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in wifi_mngr_api.h Auto-Connect The auto-connect will do automatically connect to stored AP while the WI-FI connection offline, and will periodcially to retry till connected or been disable. Initialize Enable auto-connect and add related file into Keil project #define WM_ENABLED (1) #define AC_ENABLED (1) Info The auto-Connect will be init while initating WI-FI manager. Usage See in API reference How To... Network Manager Network Manager provides mechanism to configure and monitor Wi-Fi networking. We strongly recommend applying Network Manager due to the Network Manager could make the process more robustly. Once the Network Manager initialize done, developer could start to perform the network process via Network Manager How to perform Wi-Fi scan WI-FI scan request via Network Manager T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information. How to perform Wi-Fi connection according to the scan result WI-FI connect via Network Manager T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptWmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Network Manager, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWmWifiCnctConfig with scan result ptScanList typedef struct S_NmWifiCnctConfig { uint8_t u8aBssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t u8aSsid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t u8SsidLen; uint8_t u8aPwd[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t u8PwdLen; // The length of the password. If the length is 64, the password is regarded as PMK. uint8_t u8Timeout; // Connect timeout } T_NmWifiCnctConfig; WI-FI Manager It is not necessary to access Wi-Fi Manager if Network Manager is enabled. However, developer can disable Network Manager and apply Wi-Fi Manager to perform network process directly. Before performing any Wi-Fi operation, developer should trigger Wi-Fi initial first. How to perform Wi-Fi initiate Wi-Fi initiate via Wi-Fi manager T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that initiate is done. After receiving, application can trigger the following Wi-Fi operation. Both user application and the auto-connect module might trigger Wi-Fi operation. The user application should turn off auto-connect module before trigger any Wi-Fi operation. WI-FI auto connect disable request T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb) If blActDisconnect is true that disable auto-connect module. Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect disable done. Once user Wi-Fi operation completed, application can turn on auto-connect module again. WI-FI auto connect enable request T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect enable done. How to perform Wi-Fi scan WI-FI scan request via Wi-Fi Manager T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Configurate scan configuration ptWifiScanConfig typedef struct { uint8_t *ssid; /**< SSID of AP */ uint8_t *bssid; /**< MAC address of AP, point to array[WIFI_MAC_ADDRESS_LENGTH] */ uint8_t channel; /**< channel, scan the specific channel */ bool show_hidden; /**< enable to scan AP whose SSID is hidden */ wifi_scan_type_t scan_type; /**< scan type, active or passive */ wifi_scan_time_t scan_time; /**< scan time per channel */ } wifi_scan_config_t; The ssid and bssid could be empty if developer want to scan global APs. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information. How to perform Wi-Fi connect according to the scan result WI-FI connect request via WI-FI Manager T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Wi-Fi, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWifiConnConfig with scan result ptScanList typedef struct S_WmConnConfig { uint8_t ssid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t ssid_length; // The length of the SSID. uint8_t bssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t password[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t password_length; // The length of the password. If the length is 64, the password is regarded as PMK. } __attribute__((packed)) T_WmConnConfig;","title":"WI-Fi"},{"location":"application-guide/wifi/#wi-fi","text":"Descript of WI-FI manager & Network Manager & Auto-Connect","title":"WI-FI"},{"location":"application-guide/wifi/#network-manager","text":"Network manager can handling wifi manager & auto-connect interactive behavior to let user only care about triggering WI-FI scan request and connect request. Info To see the usage example of Network Manager, can check in qd_app in examples\\start_up\\ folder. The network manager initiation will also initialize the wifi manager and auto-connect. It's not necessary to initiate again in application","title":"Network Manager"},{"location":"application-guide/wifi/#initialize","text":"Before using the network manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/wifi/#step-1-enable-network-manager","text":"#define WM_ENABLED (1) #define NM_ENABLED (1) #define AC_ENABLED (1) The definition been defined in qd_config.h in sys_config folder. Warning WM_ENABLED and AC_ENABLED are both required if using network manager. (The AC_ENABLED definition will be force to set as true while NM_ENABLED been set.)","title":"Step 1. Enable network manager"},{"location":"application-guide/wifi/#step-2-add-related-files-in-keil-project","text":"","title":"Step 2. Add related files in Keil project"},{"location":"application-guide/wifi/#step-3-register-callback-and-init","text":"Add below program in app_main.c void APP_NmUnsolicitedCallback(T_NmUslctdEvtType tEvtType, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to net_mngr_api.h switch(tEvtType) { case NM_USLCTD_EVT_NETWORK_UP: { // wifi connected & got ip event break; } case NM_USLCTD_EVT_NETWORK_DOWN: { // wifi disconnect event break; } case NM_USLCTD_EVT_NETWORK_RESET: { // wifi reset event break; } default: { // should not be here break; } } } void APP_NetInit(void) { // Network manager initialize (auto-connect enable) APP_NmInit(true, &APP_NmUnsolicitedCallback); // user implement } The first parameter of APP_NmInit() is to enable/disable auto-connect at started. If set as true - the auto-connect will directly be funtional in sequence. If set as false - the auto-connect won't active. Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/wifi/#unsolicited-callback-indicate-callback","text":"There're two types of callback function pointer can be assign to Network manager Unsolicited callback - Used for recving unsolicited events from network manager, will be called in network up (Wi-Fi connected & IP got)/ network down/ WI-FI reset. Info network up event represents to WI-FI connected and got dhcp ip Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to network manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in nm_mngr_api.h","title":"Unsolicited callback &amp; Indicate callback"},{"location":"application-guide/wifi/#wi-fi-manager","text":"WI-FI manager provide a easy way to control WI-FI. Info Network manager runs base on WI-FI manager, so if using the network manager the WI-FI manager will be directly initiate at network manager initiation.","title":"WI-FI Manager"},{"location":"application-guide/wifi/#initialize_1","text":"Before using the WI-FI manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/wifi/#step-1-enable-wi-fi-manager","text":"#define WM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder.","title":"Step 1. Enable WI-FI manager"},{"location":"application-guide/wifi/#step-2-add-related-files-in-keil-project_1","text":"","title":"Step 2. Add related files in Keil project"},{"location":"application-guide/wifi/#step-3-register-callback-and-init_1","text":"Add below program in app_main.c void APP_WmUnsolicitedCallback(T_WmUslctedEvtType tEvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to wifi_mngr_api.h switch(tEvtType) { case USLCTED_CB_EVT_WIFI_UP: { // wifi connected event break; } case USLCTED_CB_EVT_WIFI_DOWN: { // wifi disconnect event break; } case USLCTED_CB_EVT_WIFI_RESET: { // wifi reset event break; } case USLCTED_CB_EVT_GOT_IP: { // wifi got ip break; } } } void APP_WifiInitDoneIndCallback(T_OplErr tEvtRst) { APP_SendMessage(APP_EVT_WIFI_INIT_DONE, (uint8_t*)&tEvtRst, sizeof(T_OplErr)); } void APP_NetInit(void) { // register Wi-Fi unsolicited callback if(OPL_OK != Opl_Wifi_Uslctd_CB_Reg(APP_WmUnsolicitedCallback)) { OPL_LOG_ERRO(APP, \"Wi-Fi unsolicited callback regist fail\"); } // Wi-Fi manager initialize Opl_Wifi_Init_Req(APP_WifiInitDoneIndCallback); // user implement } Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/wifi/#unsolicited-callback-indicate-callback_1","text":"There're two types of callback function pointer can be assign to WI-FI manager Unsolicited callback - Used for recving unsolicited events from WI-FI, will happens in WI-FI connected/ disconnected/ reset/ got ip. Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to WI-FI manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in wifi_mngr_api.h","title":"Unsolicited callback &amp; Indicate callback"},{"location":"application-guide/wifi/#auto-connect","text":"The auto-connect will do automatically connect to stored AP while the WI-FI connection offline, and will periodcially to retry till connected or been disable.","title":"Auto-Connect"},{"location":"application-guide/wifi/#initialize_2","text":"Enable auto-connect and add related file into Keil project #define WM_ENABLED (1) #define AC_ENABLED (1) Info The auto-Connect will be init while initating WI-FI manager.","title":"Initialize"},{"location":"application-guide/wifi/#usage","text":"See in API reference","title":"Usage"},{"location":"application-guide/wifi/#how-to","text":"","title":"How To..."},{"location":"application-guide/wifi/#network-manager_1","text":"Network Manager provides mechanism to configure and monitor Wi-Fi networking. We strongly recommend applying Network Manager due to the Network Manager could make the process more robustly. Once the Network Manager initialize done, developer could start to perform the network process via Network Manager","title":"Network Manager"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-scan","text":"WI-FI scan request via Network Manager T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information.","title":"How to perform Wi-Fi scan"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-connection-according-to-the-scan-result","text":"WI-FI connect via Network Manager T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptWmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Network Manager, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWmWifiCnctConfig with scan result ptScanList typedef struct S_NmWifiCnctConfig { uint8_t u8aBssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t u8aSsid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t u8SsidLen; uint8_t u8aPwd[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t u8PwdLen; // The length of the password. If the length is 64, the password is regarded as PMK. uint8_t u8Timeout; // Connect timeout } T_NmWifiCnctConfig;","title":"How to perform Wi-Fi connection according to the scan result"},{"location":"application-guide/wifi/#wi-fi-manager_1","text":"It is not necessary to access Wi-Fi Manager if Network Manager is enabled. However, developer can disable Network Manager and apply Wi-Fi Manager to perform network process directly. Before performing any Wi-Fi operation, developer should trigger Wi-Fi initial first.","title":"WI-FI Manager"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-initiate","text":"Wi-Fi initiate via Wi-Fi manager T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that initiate is done. After receiving, application can trigger the following Wi-Fi operation. Both user application and the auto-connect module might trigger Wi-Fi operation. The user application should turn off auto-connect module before trigger any Wi-Fi operation. WI-FI auto connect disable request T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb) If blActDisconnect is true that disable auto-connect module. Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect disable done. Once user Wi-Fi operation completed, application can turn on auto-connect module again. WI-FI auto connect enable request T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect enable done.","title":"How to perform Wi-Fi initiate"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-scan_1","text":"WI-FI scan request via Wi-Fi Manager T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Configurate scan configuration ptWifiScanConfig typedef struct { uint8_t *ssid; /**< SSID of AP */ uint8_t *bssid; /**< MAC address of AP, point to array[WIFI_MAC_ADDRESS_LENGTH] */ uint8_t channel; /**< channel, scan the specific channel */ bool show_hidden; /**< enable to scan AP whose SSID is hidden */ wifi_scan_type_t scan_type; /**< scan type, active or passive */ wifi_scan_time_t scan_time; /**< scan time per channel */ } wifi_scan_config_t; The ssid and bssid could be empty if developer want to scan global APs. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information.","title":"How to perform Wi-Fi scan"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-connect-according-to-the-scan-result","text":"WI-FI connect request via WI-FI Manager T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Wi-Fi, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWifiConnConfig with scan result ptScanList typedef struct S_WmConnConfig { uint8_t ssid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t ssid_length; // The length of the SSID. uint8_t bssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t password[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t password_length; // The length of the password. If the length is 64, the password is regarded as PMK. } __attribute__((packed)) T_WmConnConfig;","title":"How to perform Wi-Fi connect according to the scan result"},{"location":"application-guide/wifi_provision_via_ble/","text":"WI-FI provision via BLE This block diagram introduces how to provision Wi-Fi credentials of the Home AP via the Bluetooth low energy (BLE). When the phone (ble central) wants to execute wi-fi provision via ble, it can send wi-fi provision message to BLE Application via BLE Manager. BLE Appication is responsible for parsing the Wi-Fi provision message and sending it to the Network manager for processing according to different events (eg. Wi-Fi scan or Wi-Fi connect). Finally, pass the corresponding response (e.g. scan list result) to the BLE Application via the call back function of Network Manager and then pass it to the phone (BLE central) via BLE Manager. The developer can refer to QD_APP Provision Process Creates an user defined service (e.g. quick_dev\\app_ref\\opl_svc.c ) The user defined service could create a gatt handler (e.g. OPL_Svc_GattDispatchHandler() ) to pass Wi-Fi provision message from phone (BLE central) to BLE Application. The developer can refer to BluetoothLE Use BLE Application receive handler in application The developer can use BLE Application receive handler OPL_DataRecvHandler(uint8_t *pu8Data, uint16_t u16DataLen) to send Wi-Fi provision message to BLE Application quick_dev\\app_ref\\ble_data_prot\\opl_data_prot.c when BLE Application gets Wi-Fi provision message, it parses this message and then send this parsed message to Network Manager to excute Wi-Fi request. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } How to... How to create an user defined service (e.g. quick_dev\\app_ref\\ble_data_prot\\opl_svc.c ) in BLE Manager Please refer to BluetoothLE How to receive BLE data in and then export to BLE Application in application Create a gatt dispatch handler (e.g. OPL_Svc_GattDispatchHandler() ) in user defined service static T_OplErr OPL_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { OPL_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { OPL_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_TO_PEER_CFM, NULL, 0, 0); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } This example is receiving LE_GATT_MSG_ACCESS_WRITE_IND event to handle BLE data via OPL_Svc_GattDispatchWriteHandler() tatic void OPL_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tOplSvcHandle.ptSvcDef->startHdl; switch(u16AttrId) { case OPL_SVC_IDX_DATA_IN_VAL: { APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case OPL_SVC_IDX_DATA_OUT_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tOplSvcHandle.ptSvcDef, OPL_SVC_IDX_DATA_OUT_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } If receiving OPL_SVC_IDX_DATA_IN_VAL , OPL_Svc_GattDispatchWriteHandler() could send BLE data to application via APP_SendMessage() In application, developer could create a function (e.g. APP_EvtHandler_BleDataInd() ) to send BLE data to BLE Application. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } How to handle Wi-Fi provision message via BLE in BLE Application BLE Application is responsible for parsing the messages from BLE, and then processing these events by category. Wi-Fi provision messages include Wi-Fi scan, Wi-Fi connect, Wi-Fi disconnect, Wi-Fi reconnect, read device Wi-Fi information, write Wi-Fi device information, get device Wi-Fi status and reset Wi-Fi. It is a BLE Application event handler table g_tOplDataEventHandlerTbl to handle these events. static T_OplDataEventTable g_tOplDataEventHandlerTbl[] = { {OPL_DATA_REQ_SCAN, OPL_DataProtocol_Scan}, {OPL_DATA_REQ_CONNECT, OPL_DataProtocol_Connect}, {OPL_DATA_REQ_DISCONNECT, OPL_DataProtocol_Disconnect}, {OPL_DATA_REQ_RECONNECT, OPL_DataProtocol_Reconnect}, {OPL_DATA_REQ_READ_DEVICE_INFO, OPL_DataProtocol_ReadDeviceInfo}, {OPL_DATA_REQ_WRITE_DEVICE_INFO, OPL_DataProtocol_WriteDeviceInfo}, {OPL_DATA_REQ_WIFI_STATUS, OPL_DataProtocol_WifiStatus}, {OPL_DATA_REQ_RESET, OPL_DataProtocol_Reset}, For example, if receiving OPL_DATA_REQ_SCAN , OPL_DataProtocol_Scan handler will send Wi-Fi scan message to Network Manager to execute Wi-Fi scan. static void OPL_DataProtocol_Scan(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_SCAN\"); // reset connection config table memset(&g_tOplDataConnCfg, 0, sizeof(T_OplDataConnCfg)); g_tOplDataConnCfg.u8ConnectType = OPL_DATA_CONN_TYPE_BSSID; // trigger scan request APP_NmWifiScanReq(OPL_DataHandler_WifiScanDoneIndCb); } How to respnose Wi-Fi process result to phone BLE Application send Wi-Fi provision message to Network Manager, and then Network Manager will create a callback function to handle indicate callback. For example, if Wi-Fi scan done, the Wi-FI scan done callback OPL_DataHandler_WifiScanDoneIndCb will follow up on scan done. void OPL_DataHandler_WifiScanDoneIndCb(T_OplErr tEvtRst) { OPL_LOG_DEBG(OPL, \"Wifi scan done ind %d\", tEvtRst); if(OPL_DATA_CONN_TYPE_BSSID == g_tOplDataConnCfg.u8ConnectType) { // CK_DATA_REQ_SCAN cmd, just do report scan list _OPL_DataHandler_SendScanReport(); OPL_DataSendResponse(OPL_DATA_RSP_SCAN_END, 0); } } _OPL_DataHandler_SendScanReport will obtain the information of APs via Wi-Fi Manager in the environment, and sort out the AP list. static int _OPL_DataHandler_SendScanReport(void) { wifi_scan_info_t *pstAPList = NULL; wifi_auto_connect_info_t *info = NULL; T_WmScanInfo *pstWifiAPList = NULL; uint8_t u8APPAutoConnectGetApNum = 0; // uint8_t u8IsUpdate = false; uint16_t u16apCount = 0; int32_t i = 0, j = 0; // TODO: get ap number Opl_Wifi_ApNum_Get(&u16apCount); OPL_LOG_INFO(OPL, \"AP num = %d\", u16apCount); pstAPList = (wifi_scan_info_t *)malloc(sizeof(wifi_scan_info_t) * u16apCount); // TODO: get ap record Opl_Wifi_ApRecord_Get(&u16apCount, pstAPList); pstWifiAPList = (T_WmScanInfo *)malloc(sizeof(T_WmScanInfo) * u16apCount); memset(pstWifiAPList , 0 , sizeof(T_WmScanInfo) * u16apCount); // TODO: get auto connect ap number Opl_Wifi_AutoConnectApNum_Get(&u8APPAutoConnectGetApNum); if (u8APPAutoConnectGetApNum) { info = (wifi_auto_connect_info_t *)malloc(sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); memset(info, 0, sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); for (i = 0; i < u8APPAutoConnectGetApNum; i++) { // TODO: get auto connected ap info Opl_Wifi_AutoConnectApInfo_Get(i, info + i); } /* build blewifi ap list */ for (i = 0; i < u16apCount; ++i) { memcpy(pstWifiAPList[i].ssid, pstAPList[i].ssid, sizeof(pstAPList[i].ssid)); memcpy(pstWifiAPList[i].bssid, pstAPList[i].bssid, WIFI_MAC_ADDRESS_LENGTH); pstWifiAPList[i].rssi = pstAPList[i].rssi; pstWifiAPList[i].auth_mode = pstAPList[i].auth_mode; pstWifiAPList[i].ssid_length = strlen((const char *)pstAPList[i].ssid); pstWifiAPList[i].connected = 0; #if (1 == FLITER_STRONG_AP_EN) pstWifiAPList[i].u8IgnoreReport = false; #endif for (j = 0; j < u8APPAutoConnectGetApNum; j++) { if ((info+j)->ap_channel) { if(!memcmp(pstWifiAPList[i].ssid, (info+j)->ssid, sizeof((info+j)->ssid)) && !memcmp(pstWifiAPList[i].bssid, (info+j)->bssid, sizeof((info+j)->bssid))) { pstWifiAPList[i].connected = 1; break; } } } } /* Send Data to BLE */ /* Send AP inforamtion individually */ for (i = 0; i < u16apCount; ++i) { #if (1 == FLITER_STRONG_AP_EN) if(true == pstWifiAPList[i].u8IgnoreReport) { continue; } #endif if(pstWifiAPList[i].ssid_length != 0) { _OPL_DataHandler_SendSignalScanReport(1, &pstWifiAPList[i]); osDelay(100); } } if (pstAPList) free(pstAPList); if (pstWifiAPList) free(pstWifiAPList); if (info) free(info); return ubAppErr; } _OPL_DataHandler_SendSignalScanReport will organize the AP list static void _OPL_DataHandler_SendSignalScanReport(uint16_t apCount, T_WmScanInfo *ap_list) { uint8_t *data; int data_len; uint8_t *pos; int malloc_size = sizeof(T_WmScanInfo) * apCount; pos = data = malloc(malloc_size); if (data == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } for (int i = 0; i < apCount; ++i) { uint8_t len = ap_list[i].ssid_length; data_len = (pos - data); *pos++ = len; memcpy(pos, ap_list[i].ssid, len); pos += len; memcpy(pos, ap_list[i].bssid,6); pos += 6; *pos++ = ap_list[i].auth_mode; *pos++ = ap_list[i].rssi; #ifdef CK_DATA_USE_CONNECTED *pos++ = ap_list[i].connected; #else *pos++ = 0; #endif } data_len = (pos - data); /* create scan report data packet */ OPL_DataSendEncap(OPL_DATA_RSP_SCAN_REPORT, data, data_len); free(data); } OPL_DataSendEncap is responsible for packing data in accordance with BLE packet format. void OPL_DataSendEncap(uint16_t u16Type, uint8_t *pu8Data, uint32_t u32TotalDataLen) { T_OplDataHdrTag *tHdrTag = NULL; int remain_len = u32TotalDataLen; /* 1.fragment data packet to fit MTU size */ /* 2.Pack blewifi header */ tHdrTag = malloc(sizeof(T_OplDataHdrTag) + remain_len); if (tHdrTag == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } tHdrTag->u16EventId = u16Type; tHdrTag->u16DataLen = remain_len; if (tHdrTag->u16DataLen) memcpy(tHdrTag->au8Data, pu8Data, tHdrTag->u16DataLen); /* 3.send app data to BLE stack */ Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_DATA, (uint8_t *)tHdrTag, (tHdrTag->u16DataLen + sizeof(T_OplDataHdrTag)), 0); free(tHdrTag); } Opl_Ble_Send_Message is responsible for sending scan done result (e.g. AP list) to phone via BLE Manager.","title":"WI-FI Provision Via BLE"},{"location":"application-guide/wifi_provision_via_ble/#wi-fi-provision-via-ble","text":"This block diagram introduces how to provision Wi-Fi credentials of the Home AP via the Bluetooth low energy (BLE). When the phone (ble central) wants to execute wi-fi provision via ble, it can send wi-fi provision message to BLE Application via BLE Manager. BLE Appication is responsible for parsing the Wi-Fi provision message and sending it to the Network manager for processing according to different events (eg. Wi-Fi scan or Wi-Fi connect). Finally, pass the corresponding response (e.g. scan list result) to the BLE Application via the call back function of Network Manager and then pass it to the phone (BLE central) via BLE Manager. The developer can refer to QD_APP","title":"WI-FI provision via BLE"},{"location":"application-guide/wifi_provision_via_ble/#provision-process","text":"Creates an user defined service (e.g. quick_dev\\app_ref\\opl_svc.c ) The user defined service could create a gatt handler (e.g. OPL_Svc_GattDispatchHandler() ) to pass Wi-Fi provision message from phone (BLE central) to BLE Application. The developer can refer to BluetoothLE Use BLE Application receive handler in application The developer can use BLE Application receive handler OPL_DataRecvHandler(uint8_t *pu8Data, uint16_t u16DataLen) to send Wi-Fi provision message to BLE Application quick_dev\\app_ref\\ble_data_prot\\opl_data_prot.c when BLE Application gets Wi-Fi provision message, it parses this message and then send this parsed message to Network Manager to excute Wi-Fi request. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); }","title":"Provision Process"},{"location":"application-guide/wifi_provision_via_ble/#how-to","text":"","title":"How to..."},{"location":"application-guide/wifi_provision_via_ble/#how-to-create-an-user-defined-service-eg-quick_devapp_refble_data_protopl_svcc-in-ble-manager","text":"Please refer to BluetoothLE","title":"How to create an user defined service (e.g. quick_dev\\app_ref\\ble_data_prot\\opl_svc.c) in BLE Manager"},{"location":"application-guide/wifi_provision_via_ble/#how-to-receive-ble-data-in-and-then-export-to-ble-application-in-application","text":"Create a gatt dispatch handler (e.g. OPL_Svc_GattDispatchHandler() ) in user defined service static T_OplErr OPL_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { OPL_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { OPL_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_TO_PEER_CFM, NULL, 0, 0); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } This example is receiving LE_GATT_MSG_ACCESS_WRITE_IND event to handle BLE data via OPL_Svc_GattDispatchWriteHandler() tatic void OPL_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tOplSvcHandle.ptSvcDef->startHdl; switch(u16AttrId) { case OPL_SVC_IDX_DATA_IN_VAL: { APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case OPL_SVC_IDX_DATA_OUT_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tOplSvcHandle.ptSvcDef, OPL_SVC_IDX_DATA_OUT_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } If receiving OPL_SVC_IDX_DATA_IN_VAL , OPL_Svc_GattDispatchWriteHandler() could send BLE data to application via APP_SendMessage() In application, developer could create a function (e.g. APP_EvtHandler_BleDataInd() ) to send BLE data to BLE Application. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); }","title":"How to receive BLE data in and then export to BLE Application in application"},{"location":"application-guide/wifi_provision_via_ble/#how-to-handle-wi-fi-provision-message-via-ble-in-ble-application","text":"BLE Application is responsible for parsing the messages from BLE, and then processing these events by category. Wi-Fi provision messages include Wi-Fi scan, Wi-Fi connect, Wi-Fi disconnect, Wi-Fi reconnect, read device Wi-Fi information, write Wi-Fi device information, get device Wi-Fi status and reset Wi-Fi. It is a BLE Application event handler table g_tOplDataEventHandlerTbl to handle these events. static T_OplDataEventTable g_tOplDataEventHandlerTbl[] = { {OPL_DATA_REQ_SCAN, OPL_DataProtocol_Scan}, {OPL_DATA_REQ_CONNECT, OPL_DataProtocol_Connect}, {OPL_DATA_REQ_DISCONNECT, OPL_DataProtocol_Disconnect}, {OPL_DATA_REQ_RECONNECT, OPL_DataProtocol_Reconnect}, {OPL_DATA_REQ_READ_DEVICE_INFO, OPL_DataProtocol_ReadDeviceInfo}, {OPL_DATA_REQ_WRITE_DEVICE_INFO, OPL_DataProtocol_WriteDeviceInfo}, {OPL_DATA_REQ_WIFI_STATUS, OPL_DataProtocol_WifiStatus}, {OPL_DATA_REQ_RESET, OPL_DataProtocol_Reset}, For example, if receiving OPL_DATA_REQ_SCAN , OPL_DataProtocol_Scan handler will send Wi-Fi scan message to Network Manager to execute Wi-Fi scan. static void OPL_DataProtocol_Scan(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_SCAN\"); // reset connection config table memset(&g_tOplDataConnCfg, 0, sizeof(T_OplDataConnCfg)); g_tOplDataConnCfg.u8ConnectType = OPL_DATA_CONN_TYPE_BSSID; // trigger scan request APP_NmWifiScanReq(OPL_DataHandler_WifiScanDoneIndCb); }","title":"How to handle Wi-Fi provision message via BLE in BLE Application"},{"location":"application-guide/wifi_provision_via_ble/#how-to-respnose-wi-fi-process-result-to-phone","text":"BLE Application send Wi-Fi provision message to Network Manager, and then Network Manager will create a callback function to handle indicate callback. For example, if Wi-Fi scan done, the Wi-FI scan done callback OPL_DataHandler_WifiScanDoneIndCb will follow up on scan done. void OPL_DataHandler_WifiScanDoneIndCb(T_OplErr tEvtRst) { OPL_LOG_DEBG(OPL, \"Wifi scan done ind %d\", tEvtRst); if(OPL_DATA_CONN_TYPE_BSSID == g_tOplDataConnCfg.u8ConnectType) { // CK_DATA_REQ_SCAN cmd, just do report scan list _OPL_DataHandler_SendScanReport(); OPL_DataSendResponse(OPL_DATA_RSP_SCAN_END, 0); } } _OPL_DataHandler_SendScanReport will obtain the information of APs via Wi-Fi Manager in the environment, and sort out the AP list. static int _OPL_DataHandler_SendScanReport(void) { wifi_scan_info_t *pstAPList = NULL; wifi_auto_connect_info_t *info = NULL; T_WmScanInfo *pstWifiAPList = NULL; uint8_t u8APPAutoConnectGetApNum = 0; // uint8_t u8IsUpdate = false; uint16_t u16apCount = 0; int32_t i = 0, j = 0; // TODO: get ap number Opl_Wifi_ApNum_Get(&u16apCount); OPL_LOG_INFO(OPL, \"AP num = %d\", u16apCount); pstAPList = (wifi_scan_info_t *)malloc(sizeof(wifi_scan_info_t) * u16apCount); // TODO: get ap record Opl_Wifi_ApRecord_Get(&u16apCount, pstAPList); pstWifiAPList = (T_WmScanInfo *)malloc(sizeof(T_WmScanInfo) * u16apCount); memset(pstWifiAPList , 0 , sizeof(T_WmScanInfo) * u16apCount); // TODO: get auto connect ap number Opl_Wifi_AutoConnectApNum_Get(&u8APPAutoConnectGetApNum); if (u8APPAutoConnectGetApNum) { info = (wifi_auto_connect_info_t *)malloc(sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); memset(info, 0, sizeof(wifi_auto_connect_info_t) * u8APPAutoConnectGetApNum); for (i = 0; i < u8APPAutoConnectGetApNum; i++) { // TODO: get auto connected ap info Opl_Wifi_AutoConnectApInfo_Get(i, info + i); } /* build blewifi ap list */ for (i = 0; i < u16apCount; ++i) { memcpy(pstWifiAPList[i].ssid, pstAPList[i].ssid, sizeof(pstAPList[i].ssid)); memcpy(pstWifiAPList[i].bssid, pstAPList[i].bssid, WIFI_MAC_ADDRESS_LENGTH); pstWifiAPList[i].rssi = pstAPList[i].rssi; pstWifiAPList[i].auth_mode = pstAPList[i].auth_mode; pstWifiAPList[i].ssid_length = strlen((const char *)pstAPList[i].ssid); pstWifiAPList[i].connected = 0; #if (1 == FLITER_STRONG_AP_EN) pstWifiAPList[i].u8IgnoreReport = false; #endif for (j = 0; j < u8APPAutoConnectGetApNum; j++) { if ((info+j)->ap_channel) { if(!memcmp(pstWifiAPList[i].ssid, (info+j)->ssid, sizeof((info+j)->ssid)) && !memcmp(pstWifiAPList[i].bssid, (info+j)->bssid, sizeof((info+j)->bssid))) { pstWifiAPList[i].connected = 1; break; } } } } /* Send Data to BLE */ /* Send AP inforamtion individually */ for (i = 0; i < u16apCount; ++i) { #if (1 == FLITER_STRONG_AP_EN) if(true == pstWifiAPList[i].u8IgnoreReport) { continue; } #endif if(pstWifiAPList[i].ssid_length != 0) { _OPL_DataHandler_SendSignalScanReport(1, &pstWifiAPList[i]); osDelay(100); } } if (pstAPList) free(pstAPList); if (pstWifiAPList) free(pstWifiAPList); if (info) free(info); return ubAppErr; } _OPL_DataHandler_SendSignalScanReport will organize the AP list static void _OPL_DataHandler_SendSignalScanReport(uint16_t apCount, T_WmScanInfo *ap_list) { uint8_t *data; int data_len; uint8_t *pos; int malloc_size = sizeof(T_WmScanInfo) * apCount; pos = data = malloc(malloc_size); if (data == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } for (int i = 0; i < apCount; ++i) { uint8_t len = ap_list[i].ssid_length; data_len = (pos - data); *pos++ = len; memcpy(pos, ap_list[i].ssid, len); pos += len; memcpy(pos, ap_list[i].bssid,6); pos += 6; *pos++ = ap_list[i].auth_mode; *pos++ = ap_list[i].rssi; #ifdef CK_DATA_USE_CONNECTED *pos++ = ap_list[i].connected; #else *pos++ = 0; #endif } data_len = (pos - data); /* create scan report data packet */ OPL_DataSendEncap(OPL_DATA_RSP_SCAN_REPORT, data, data_len); free(data); } OPL_DataSendEncap is responsible for packing data in accordance with BLE packet format. void OPL_DataSendEncap(uint16_t u16Type, uint8_t *pu8Data, uint32_t u32TotalDataLen) { T_OplDataHdrTag *tHdrTag = NULL; int remain_len = u32TotalDataLen; /* 1.fragment data packet to fit MTU size */ /* 2.Pack blewifi header */ tHdrTag = malloc(sizeof(T_OplDataHdrTag) + remain_len); if (tHdrTag == NULL) { OPL_LOG_ERRO(OPL, \"malloc fail\"); return; } tHdrTag->u16EventId = u16Type; tHdrTag->u16DataLen = remain_len; if (tHdrTag->u16DataLen) memcpy(tHdrTag->au8Data, pu8Data, tHdrTag->u16DataLen); /* 3.send app data to BLE stack */ Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_DATA, (uint8_t *)tHdrTag, (tHdrTag->u16DataLen + sizeof(T_OplDataHdrTag)), 0); free(tHdrTag); } Opl_Ble_Send_Message is responsible for sending scan done result (e.g. AP list) to phone via BLE Manager.","title":"How to respnose Wi-Fi process result to phone"},{"location":"examples/ble_example/","text":"BLE example BLE example is intended to demonstrate the BLE functionality, and to provide code that you can copy and adapt into your own projects BLE battery service This example creates BLE battery service with the Battery Level characteristic to monitor battery levels. This example application is in \\examples\\ble\\ble_svc_battery . The BLE battery service is in \\quick_dev\\app_ref\\ble_services\\bas_svc.c . During initialization, it starts system timers and adds battery services and battery level characteristic. After the timer timeout, the device will notify the client the battery level characteristics. BLE data input/output service This example creates BLE data input/output service send or receive data via BLE. The example application is in \\examples\\ble\\ble_svc_data_io . The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . When the user sends data, the data will be sent to the Le task first. Then Le task will pass the data into the GattDispatchHandler in User define Service. According data's access permission that include read, write or notify, developer could create different handler to handle. This example use write handler GattWriteHandler to handle write access data from phone (APP). GattWriteHandler will be responsible for passing the data to the application, and the application will return the respnose to the phone (APP) via DataoutNotify.","title":"BLE"},{"location":"examples/ble_example/#ble-example","text":"BLE example is intended to demonstrate the BLE functionality, and to provide code that you can copy and adapt into your own projects","title":"BLE example"},{"location":"examples/ble_example/#ble-battery-service","text":"This example creates BLE battery service with the Battery Level characteristic to monitor battery levels. This example application is in \\examples\\ble\\ble_svc_battery . The BLE battery service is in \\quick_dev\\app_ref\\ble_services\\bas_svc.c . During initialization, it starts system timers and adds battery services and battery level characteristic. After the timer timeout, the device will notify the client the battery level characteristics.","title":"BLE battery service"},{"location":"examples/ble_example/#ble-data-inputoutput-service","text":"This example creates BLE data input/output service send or receive data via BLE. The example application is in \\examples\\ble\\ble_svc_data_io . The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . When the user sends data, the data will be sent to the Le task first. Then Le task will pass the data into the GattDispatchHandler in User define Service. According data's access permission that include read, write or notify, developer could create different handler to handle. This example use write handler GattWriteHandler to handle write access data from phone (APP). GattWriteHandler will be responsible for passing the data to the application, and the application will return the respnose to the phone (APP) via DataoutNotify.","title":"BLE data input/output service"},{"location":"examples/cloud_example/","text":"TCP Cloud This TCP Cloud Demo is the application utilizes the TCP cloud ported from cloud template so that the OPL device can connect to TCP server. The example application is in \\examples\\cloud\\tcp_demo . The TCP Cloud is in \\quick_dev\\app_ref\\cloud\\tcp_cloud . This example is mainly to demonstrate how to connect to the TCP Server after connecting to Wi-Fi. In the beginning of this example, it will connect to Wi-Fi using BLE broadcast, as in QD_APP (see QD_APP for details). This example is mainly to demonstrate how to connect to the TCP Server after connecting to Wi-Fi, and the TCP Server we apply is \"SocketTest\" (url: http://sockettest.sourceforge.net/). A JAVA environment is necessary to run the \"SocketTest\" server. After running SocketTest, press \"Start Listening\". 1. How to connect and send message to TCP Server In this example, if the user wants to connect to the TCP Server, issue AT command \"at+tcpconnet= IP address,port\" to send the TCP connection request. After sending the TCP connection request, the TCP Server will connect and send the result back to the Device. The \"TCP connect\" message will show in DBG mode of terminal window. After connected, if the user can send data to the TCP Server. Issue AT command \"at+tcpsend= the message user wants to send\u201d to send data to the TCP Server. Server will receive the same data and display in server console. 2. Keep alive demonstration After connected, issue AT command \u201cat+smartsleep\u201d to turn on Smart Sleep mode. Even in sleep mode, the device will still send a \"ping\" message to the TCP Server every 10000ms(10S). The purpose is to tell the TCP Server that the device is still alive. Server will receive the \"Ping\" message and display in server console. 3. Receive message After device connected to server and enter Sleep mode, input message in \"Send Message\" textbox of \"SocketTest\". Server will send the message to the device. After receiving in device side, the message will display in DBG Console. MQTT Cloud This MQTT Cloud Demo is the application utilizes the MQTT cloud ported from cloud template so that the OPL device can connect/subscribe/publish to MQTT server. The example application is in \\examples\\cloud\\mqtt_demo . The MQTT cloud is in \\quick_dev\\app_ref\\cloud\\mqtt_cloud . This example is mainly to demonstrate how to connect to the MQTT Server and publish and subscribe Topic after connecting to Wi-Fi. The MQTT server (Broker) will hand-over the data from client who published to client who subscribed, it is a center role of MQTT system. And all the clients are connected to same Broker and using topic subscribe/publish mechanism to transmit and receive data. So as the MQTT demo, user will need to install a client on your PC to create a demonstration environment. Setup remote MQTT client First, we have to setup another remote MQTT client (a soft MQTT client running on PC). The MQTT client tool we apply in this example is \"MQTTX\" (url: https://www.emqx.com/en/downloads/MQTTX/v1.8.1/MQTTX-Setup-1.8.1-x64.exe). After installed, open the tool and setup like screen shot. Press \u201d+\u201d to create new connections, and the general setup descripts are. Name: like the name of the project, just for recognize in this tool. Client ID: the \u201cUNIQE\u201d ID for server to register, should be an only name for all the clients. Host: the demonstration of project is connected to the public MQTT server, \u201cbroker.emqx.io\u201d Port: the \u201cbroker.emqx.io\u201d port using 8883 SSL/TLS: enable authentication during connection Certificate: using CA signed server (only need server to sign the CA cert) SSL Secure: enable Add new subscription (topic from device) After filled all necessary items, press connect on right-top of this window. If connect successfully, you will see the UI like screen shot. You can add new subscription to listening the topic (red square) and publish topic (blue square). After press \u201cNew Subscription\u201d, user will see this window like the screen shot below and the default topic that device publis is \u201cQD_FWK/MQTT_DEMO/PUB_Test/1\u201d. After entering the Topic, user can press Confirm to finish building subscription and see this window like the screen shot blow The device will published \u201cHello MQTT!\u201d per 1500 ms(15s), we can also see the topic publish displayed in device debug console. Publish topic (to device) There are two topics subscribed in device side. They are \u201cQD_FWK/MQTT_DEMO/SUB_Test/1\u201d and \u201cQD_FWK/MQTT_DEMO/SUB_Test/2\u201d. User can publish same topic from MQTTX as screen shot below In device debug console, the same topic will be recevied","title":"Cloud"},{"location":"examples/cloud_example/#tcp-cloud","text":"This TCP Cloud Demo is the application utilizes the TCP cloud ported from cloud template so that the OPL device can connect to TCP server. The example application is in \\examples\\cloud\\tcp_demo . The TCP Cloud is in \\quick_dev\\app_ref\\cloud\\tcp_cloud . This example is mainly to demonstrate how to connect to the TCP Server after connecting to Wi-Fi. In the beginning of this example, it will connect to Wi-Fi using BLE broadcast, as in QD_APP (see QD_APP for details). This example is mainly to demonstrate how to connect to the TCP Server after connecting to Wi-Fi, and the TCP Server we apply is \"SocketTest\" (url: http://sockettest.sourceforge.net/). A JAVA environment is necessary to run the \"SocketTest\" server. After running SocketTest, press \"Start Listening\". 1. How to connect and send message to TCP Server In this example, if the user wants to connect to the TCP Server, issue AT command \"at+tcpconnet= IP address,port\" to send the TCP connection request. After sending the TCP connection request, the TCP Server will connect and send the result back to the Device. The \"TCP connect\" message will show in DBG mode of terminal window. After connected, if the user can send data to the TCP Server. Issue AT command \"at+tcpsend= the message user wants to send\u201d to send data to the TCP Server. Server will receive the same data and display in server console. 2. Keep alive demonstration After connected, issue AT command \u201cat+smartsleep\u201d to turn on Smart Sleep mode. Even in sleep mode, the device will still send a \"ping\" message to the TCP Server every 10000ms(10S). The purpose is to tell the TCP Server that the device is still alive. Server will receive the \"Ping\" message and display in server console. 3. Receive message After device connected to server and enter Sleep mode, input message in \"Send Message\" textbox of \"SocketTest\". Server will send the message to the device. After receiving in device side, the message will display in DBG Console.","title":"TCP Cloud"},{"location":"examples/cloud_example/#mqtt-cloud","text":"This MQTT Cloud Demo is the application utilizes the MQTT cloud ported from cloud template so that the OPL device can connect/subscribe/publish to MQTT server. The example application is in \\examples\\cloud\\mqtt_demo . The MQTT cloud is in \\quick_dev\\app_ref\\cloud\\mqtt_cloud . This example is mainly to demonstrate how to connect to the MQTT Server and publish and subscribe Topic after connecting to Wi-Fi. The MQTT server (Broker) will hand-over the data from client who published to client who subscribed, it is a center role of MQTT system. And all the clients are connected to same Broker and using topic subscribe/publish mechanism to transmit and receive data. So as the MQTT demo, user will need to install a client on your PC to create a demonstration environment. Setup remote MQTT client First, we have to setup another remote MQTT client (a soft MQTT client running on PC). The MQTT client tool we apply in this example is \"MQTTX\" (url: https://www.emqx.com/en/downloads/MQTTX/v1.8.1/MQTTX-Setup-1.8.1-x64.exe). After installed, open the tool and setup like screen shot. Press \u201d+\u201d to create new connections, and the general setup descripts are. Name: like the name of the project, just for recognize in this tool. Client ID: the \u201cUNIQE\u201d ID for server to register, should be an only name for all the clients. Host: the demonstration of project is connected to the public MQTT server, \u201cbroker.emqx.io\u201d Port: the \u201cbroker.emqx.io\u201d port using 8883 SSL/TLS: enable authentication during connection Certificate: using CA signed server (only need server to sign the CA cert) SSL Secure: enable Add new subscription (topic from device) After filled all necessary items, press connect on right-top of this window. If connect successfully, you will see the UI like screen shot. You can add new subscription to listening the topic (red square) and publish topic (blue square). After press \u201cNew Subscription\u201d, user will see this window like the screen shot below and the default topic that device publis is \u201cQD_FWK/MQTT_DEMO/PUB_Test/1\u201d. After entering the Topic, user can press Confirm to finish building subscription and see this window like the screen shot blow The device will published \u201cHello MQTT!\u201d per 1500 ms(15s), we can also see the topic publish displayed in device debug console. Publish topic (to device) There are two topics subscribed in device side. They are \u201cQD_FWK/MQTT_DEMO/SUB_Test/1\u201d and \u201cQD_FWK/MQTT_DEMO/SUB_Test/2\u201d. User can publish same topic from MQTTX as screen shot below In device debug console, the same topic will be recevied","title":"MQTT Cloud"},{"location":"examples/qd_app_example/","text":"START UP example QD APP example QD APP example is an entry example application of QuickDev Framework. It includes creation of BLE service for BLE data input/out channel, Wi-FI provision via BLE, and OTA procedure via BLE. The QD APP example is located at examples\\start_up BLE service for data input/out This BLE data input/output service implements the User Data Service to send or receive data via BLE. The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . User can issue request to device on phone app. The request will be packed as data packet and send to device. Once receiving data from phone app, the data will be transferred to the BLE Mangar through the LE task, and then the BLE Manager will transfer the data to the User Application via OPL_Service. Application will parse the data and perform indicated operation (ex. WiFi scan, WiFI connect\u2026). Device might send data to phone app also. For example, report event or status to phone app, or response the request from phone app. The application of device will issue data sending request to BLE manager. The BLE manager will send data to peer side via the service created. Wi-Fi provision via BLE Wi-Fi provision via BLE provides a mechanism to set up Wi-Fi via BLE. The Opulinks phone app provide WiFi setup function that user can perform WiFi provision via BLE to Opulinks device. User configurate Wi-Fi setup in phone app and send this request to the device (BLE peripheral) via BLE. When the phone sends Wi-Fi provision request to the device via BLE, the device utilize BLE Manager to receive this message. BLE Manager will transmit this message to application and then application will pass this message to BLE Application. BLE Application will parse this message and prepare different handler to handle different request (e.g., Wi-Fi scan request or Wi-Fi connect). These handlers would call Network Manager API to execute Wi-Fi process. When excutig Wi-Fi process done, the device wants to respnose results to the phone. Bottom layer would send Wi-Fi process response results to BLE Application via Network Manager. BLE Application would organize these Wi-Fi process response results and then pass these organized message to BLE Manager. These messages would be sent to phone by BLE Manager. Once the Wi-Fi provision via BLE is successful and Wi-Fi connection, it will automatically reconnect to the AP set by the wi-fi provision via ble after the disconnection. The following is a Wi-Fi provision via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the same MAC in APP scan result, and then press connect. Once connected, DBG console will show peer mac. Step4. Press Wifi Setup Once user press Wifi Setup, device will scan wifi and send result to APP. Choose an ap (ex, TOTOLINK). After user enter the password, it will pop up a window to tell user successful or failed. OTA via BLE The following is OTA via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the name OPL_APP_xx:xx:xx:xx (xx:xx:xx:xx are the last four significant bytes of ble mac address) in APP scan result, and then press connect. Once connected, DBG console will show peer mac. App will show the function menu (Step4). Step4. Press BLE OTA Step5. Pres Choose OTA File Step6 Choose OTA new firmware If OTA successfully, App will show","title":"START_UP"},{"location":"examples/qd_app_example/#start-up-example","text":"","title":"START UP example"},{"location":"examples/qd_app_example/#qd-app-example","text":"QD APP example is an entry example application of QuickDev Framework. It includes creation of BLE service for BLE data input/out channel, Wi-FI provision via BLE, and OTA procedure via BLE. The QD APP example is located at examples\\start_up","title":"QD APP example"},{"location":"examples/qd_app_example/#ble-service-for-data-inputout","text":"This BLE data input/output service implements the User Data Service to send or receive data via BLE. The BLE User Data Service is in \\quick_dev\\app_ref\\ble_services\\ud_svc.c . User can issue request to device on phone app. The request will be packed as data packet and send to device. Once receiving data from phone app, the data will be transferred to the BLE Mangar through the LE task, and then the BLE Manager will transfer the data to the User Application via OPL_Service. Application will parse the data and perform indicated operation (ex. WiFi scan, WiFI connect\u2026). Device might send data to phone app also. For example, report event or status to phone app, or response the request from phone app. The application of device will issue data sending request to BLE manager. The BLE manager will send data to peer side via the service created.","title":"BLE service for data input/out"},{"location":"examples/qd_app_example/#wi-fi-provision-via-ble","text":"Wi-Fi provision via BLE provides a mechanism to set up Wi-Fi via BLE. The Opulinks phone app provide WiFi setup function that user can perform WiFi provision via BLE to Opulinks device. User configurate Wi-Fi setup in phone app and send this request to the device (BLE peripheral) via BLE. When the phone sends Wi-Fi provision request to the device via BLE, the device utilize BLE Manager to receive this message. BLE Manager will transmit this message to application and then application will pass this message to BLE Application. BLE Application will parse this message and prepare different handler to handle different request (e.g., Wi-Fi scan request or Wi-Fi connect). These handlers would call Network Manager API to execute Wi-Fi process. When excutig Wi-Fi process done, the device wants to respnose results to the phone. Bottom layer would send Wi-Fi process response results to BLE Application via Network Manager. BLE Application would organize these Wi-Fi process response results and then pass these organized message to BLE Manager. These messages would be sent to phone by BLE Manager. Once the Wi-Fi provision via BLE is successful and Wi-Fi connection, it will automatically reconnect to the AP set by the wi-fi provision via ble after the disconnection. The following is a Wi-Fi provision via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the same MAC in APP scan result, and then press connect. Once connected, DBG console will show peer mac. Step4. Press Wifi Setup Once user press Wifi Setup, device will scan wifi and send result to APP. Choose an ap (ex, TOTOLINK). After user enter the password, it will pop up a window to tell user successful or failed.","title":"Wi-Fi provision via BLE"},{"location":"examples/qd_app_example/#ota-via-ble","text":"The following is OTA via BLE example of step by step Step1. Running Opulinks Utilities app Step2. Press BLE Tool and turn on device After user turn on device, DBG console will show device mac. Step3. After press BLE Tool and turn on device, find device with the name OPL_APP_xx:xx:xx:xx (xx:xx:xx:xx are the last four significant bytes of ble mac address) in APP scan result, and then press connect. Once connected, DBG console will show peer mac. App will show the function menu (Step4). Step4. Press BLE OTA Step5. Pres Choose OTA File Step6 Choose OTA new firmware If OTA successfully, App will show","title":"OTA via BLE"},{"location":"examples/wifi_example/","text":"Wi-Fi example Wi-Fi example is intended to demonstrate the Wi-Fi functionality, and to provide code that you can copy and adapt into your own projects Wi-Fi scan connect Wi-Fi scan connect example is a Wi-Fi process from Wi-Fi scan to Wi-Fi connect. First executing Wi-Fi sacn, scan to the AP in the environment. According to the scanned AP results, execute Wi-Fi connect to one of these APs. This example is in examples\\wifi\\wifi_scan_connet . After APP_init , It will start systemTimer. After timer timeout , User Application will send Scan request to Network Manager. The Network Manager will call the callback function to notify the User Application Scandone after the Scan is completed. Once the Application receives the callback function, the user can use the Scan result to select the desired wifi connection and send a Connect request to the Network Manager, and the Network Manager will call the callback function to notify the User Application after connection done. Wi-Fi quick connect Wi-Fi quick connect is a example to do the fast Wi-Fi setting. The developer can set a default AP information (ssid, password), this example skips some Wi-Fi process (e.g. Wi-Fi scan) and notify the bottom layer to connect to this AP directly. If disconnecting to the default AP, this example will re-connect this AP automatically. This example is in examples\\wifi\\wifi_quick_connect . After APP_init, it will start SystemTimer. After timer timeout, User Application will get default SSID and Password from qd_config. Then Network Manager use the AP information to pass to bottom layer that implement WI-FI scan and Network Manager will clear all old AP recorders for saving this AP information to auto-connect if WI-FI disconnect then Network Manager retrieve the scan result (ex: AP bssid) to pass to bottom layer that could use the AP bssid to implement WI-FI connect. By the way, the AP information could be brought by the third party (MCU).","title":"WI-FI"},{"location":"examples/wifi_example/#wi-fi-example","text":"Wi-Fi example is intended to demonstrate the Wi-Fi functionality, and to provide code that you can copy and adapt into your own projects","title":"Wi-Fi example"},{"location":"examples/wifi_example/#wi-fi-scan-connect","text":"Wi-Fi scan connect example is a Wi-Fi process from Wi-Fi scan to Wi-Fi connect. First executing Wi-Fi sacn, scan to the AP in the environment. According to the scanned AP results, execute Wi-Fi connect to one of these APs. This example is in examples\\wifi\\wifi_scan_connet . After APP_init , It will start systemTimer. After timer timeout , User Application will send Scan request to Network Manager. The Network Manager will call the callback function to notify the User Application Scandone after the Scan is completed. Once the Application receives the callback function, the user can use the Scan result to select the desired wifi connection and send a Connect request to the Network Manager, and the Network Manager will call the callback function to notify the User Application after connection done.","title":"Wi-Fi scan connect"},{"location":"examples/wifi_example/#wi-fi-quick-connect","text":"Wi-Fi quick connect is a example to do the fast Wi-Fi setting. The developer can set a default AP information (ssid, password), this example skips some Wi-Fi process (e.g. Wi-Fi scan) and notify the bottom layer to connect to this AP directly. If disconnecting to the default AP, this example will re-connect this AP automatically. This example is in examples\\wifi\\wifi_quick_connect . After APP_init, it will start SystemTimer. After timer timeout, User Application will get default SSID and Password from qd_config. Then Network Manager use the AP information to pass to bottom layer that implement WI-FI scan and Network Manager will clear all old AP recorders for saving this AP information to auto-connect if WI-FI disconnect then Network Manager retrieve the scan result (ex: AP bssid) to pass to bottom layer that could use the AP bssid to implement WI-FI connect. By the way, the AP information could be brought by the third party (MCU).","title":"Wi-Fi quick connect"},{"location":"get_started/get_started/","text":"Get Started Folder structure overview -examples : example applications -quick_dev : Quick-Dev framework program -sdk : Opulinks chip SDK Step 1. SDK download and install Download SDK you needed in Opulinks Github OPL1000_A3: https://github.com/Opulinks-Tech/OPL1000A3-SDK OPL2500_A0: After downloaded, the folder struct of SDK will look like below screenshot. Copy below folder into QD_FWK\\sdk\\ FW_Pack SDK Tool Step 2. Start your first application Now the sdk prepared and ready to go, open the qd_app project in : QD_FWK\\examples\\start_up\\qd_app then into the folder base on the sdk version you just inserted. For example: If download the OPL1000_A3 sdk, then open opl1000_a3 folder in qd_app project. If download the OPL2500_A0 sdk, then open opl2500_a0 folder in qd_app project. Other sdk version likewise. Open qd_app_m3.uvprojx to start Keil application. Step 3. Connect ot Dev-Kit Connect the Dev-Kit via micro-USB Step 4. Configuration setup According to Introduction mention, QD_FWK provide system configure file and module configure option file. To know the detail of the configure file, please check Project Configuration And both file qd_config.h & qd_module.h can be checked in qd_app project. Step 5. Build project Click Build and Rebuild button to compiler project. Output file qd_app_m3.bin located at <project root>\\Output\\Object\\ . Step 6. Download firmware Open download_RELEASE download tool located in sdk\\Tools\\Download\\ In Pack tag insert Script, M0 Bin, M3 Bin files. Script -> PatchData.txt ( sdk\\FW_Pack\\ ) M0 Bin -> opl1000_m0.bin ( sdk\\FW_Pack\\ ) M3 Bin -> qd_app_m3.bin ( <project root>\\Output\\Object ) Will generate opl1000.bin in sdk\\Tool\\Download\\Patch after click Pack button. In OTA tag insert OTA loader, OPL1000 Bin files. OTA loader -> opl1000_ota_loader.bin ( sdk\\FW_Pack\\ ) OPL1000 Bin -> opl1000.bin ( sdk\\Tool\\Download\\Patch\\ ) Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> auto-calculated. Will generate opl1000_ota.bin in sdk\\Tool\\Download\\Patch after click Build OTA Image button. Select UART Port in UART Setting block which connected to Dev-Kit In Download tag insert Patch Bin file to download. Patch Bin -> opl1000_ota.bin ( sdk\\Tool\\Download\\Patch ) Click download and press reset button on Dev-Kit. Step 7. Get log Open terminal (such as Tera-Term or Putty application) and connect to the target COM port and press reset button on Dev-Kit. API support To check supported API provied from QD_FWK, locate to \\app_ref\\mngr_api\\ check the header files. Network manager - \\app_ref\\mngr_api\\net_mngr_api\\net_mngr_api.h WI-FI manager - \\app_ref\\mngr_api\\wifi_mngr_api\\wifi_mngr_api.h BLE manager - \\app_ref\\mngr_api\\ble_mngr_api\\ble_mngr_api.h","title":"Get Started"},{"location":"get_started/get_started/#get-started","text":"","title":"Get Started"},{"location":"get_started/get_started/#folder-structure-overview","text":"-examples : example applications -quick_dev : Quick-Dev framework program -sdk : Opulinks chip SDK","title":"Folder structure overview"},{"location":"get_started/get_started/#step-1-sdk-download-and-install","text":"Download SDK you needed in Opulinks Github OPL1000_A3: https://github.com/Opulinks-Tech/OPL1000A3-SDK OPL2500_A0: After downloaded, the folder struct of SDK will look like below screenshot. Copy below folder into QD_FWK\\sdk\\ FW_Pack SDK Tool","title":"Step 1. SDK download and install"},{"location":"get_started/get_started/#step-2-start-your-first-application","text":"Now the sdk prepared and ready to go, open the qd_app project in : QD_FWK\\examples\\start_up\\qd_app then into the folder base on the sdk version you just inserted. For example: If download the OPL1000_A3 sdk, then open opl1000_a3 folder in qd_app project. If download the OPL2500_A0 sdk, then open opl2500_a0 folder in qd_app project. Other sdk version likewise. Open qd_app_m3.uvprojx to start Keil application.","title":"Step 2. Start your first application"},{"location":"get_started/get_started/#step-3-connect-ot-dev-kit","text":"Connect the Dev-Kit via micro-USB","title":"Step 3. Connect ot Dev-Kit"},{"location":"get_started/get_started/#step-4-configuration-setup","text":"According to Introduction mention, QD_FWK provide system configure file and module configure option file. To know the detail of the configure file, please check Project Configuration And both file qd_config.h & qd_module.h can be checked in qd_app project.","title":"Step 4. Configuration setup"},{"location":"get_started/get_started/#step-5-build-project","text":"Click Build and Rebuild button to compiler project. Output file qd_app_m3.bin located at <project root>\\Output\\Object\\ .","title":"Step 5. Build project"},{"location":"get_started/get_started/#step-6-download-firmware","text":"Open download_RELEASE download tool located in sdk\\Tools\\Download\\ In Pack tag insert Script, M0 Bin, M3 Bin files. Script -> PatchData.txt ( sdk\\FW_Pack\\ ) M0 Bin -> opl1000_m0.bin ( sdk\\FW_Pack\\ ) M3 Bin -> qd_app_m3.bin ( <project root>\\Output\\Object ) Will generate opl1000.bin in sdk\\Tool\\Download\\Patch after click Pack button. In OTA tag insert OTA loader, OPL1000 Bin files. OTA loader -> opl1000_ota_loader.bin ( sdk\\FW_Pack\\ ) OPL1000 Bin -> opl1000.bin ( sdk\\Tool\\Download\\Patch\\ ) Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> auto-calculated. Will generate opl1000_ota.bin in sdk\\Tool\\Download\\Patch after click Build OTA Image button. Select UART Port in UART Setting block which connected to Dev-Kit In Download tag insert Patch Bin file to download. Patch Bin -> opl1000_ota.bin ( sdk\\Tool\\Download\\Patch ) Click download and press reset button on Dev-Kit.","title":"Step 6. Download firmware"},{"location":"get_started/get_started/#step-7-get-log","text":"Open terminal (such as Tera-Term or Putty application) and connect to the target COM port and press reset button on Dev-Kit.","title":"Step 7. Get log"},{"location":"get_started/get_started/#api-support","text":"To check supported API provied from QD_FWK, locate to \\app_ref\\mngr_api\\ check the header files. Network manager - \\app_ref\\mngr_api\\net_mngr_api\\net_mngr_api.h WI-FI manager - \\app_ref\\mngr_api\\wifi_mngr_api\\wifi_mngr_api.h BLE manager - \\app_ref\\mngr_api\\ble_mngr_api\\ble_mngr_api.h","title":"API support"}]}