{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Quick-DEV framework Introduction QuickDev framework is designed to provide enhanced SDK middleware and product ready application reference codes to help developer for fast development. Below diagram is the whole Opulinks provided software architecture combined with QuickDev framework and Opulinks Tritium SDK. App Reference - Provides reference firmware for a complete product demonstration, the application developers can reference the source code and decide which modules to use for fast product developement. Enhanced Middleware - The middleware layer is to integrate common useful functions and features to minimize the effort for application developer for any applications. Tritium SDK - The SDK provided by Opulinks Opulinks github Advantage To provide an easy entry to develop IoT application. To provide application reference modules consist of complete IoT application functions. To provide enhanced Opulinks SDK middleware. Modelized architecture, fulfills different vendor requirement. To provide easy configuration mechanism to config different kind of applications and different modules. To provide cloud template to adapt public/private cloud. To provide pratical usage examples to facilitate developing.","title":"Introduction"},{"location":"#welcome-to-quick-dev-framework","text":"","title":"Welcome to Quick-DEV framework"},{"location":"#introduction","text":"QuickDev framework is designed to provide enhanced SDK middleware and product ready application reference codes to help developer for fast development. Below diagram is the whole Opulinks provided software architecture combined with QuickDev framework and Opulinks Tritium SDK. App Reference - Provides reference firmware for a complete product demonstration, the application developers can reference the source code and decide which modules to use for fast product developement. Enhanced Middleware - The middleware layer is to integrate common useful functions and features to minimize the effort for application developer for any applications. Tritium SDK - The SDK provided by Opulinks Opulinks github","title":"Introduction"},{"location":"#advantage","text":"To provide an easy entry to develop IoT application. To provide application reference modules consist of complete IoT application functions. To provide enhanced Opulinks SDK middleware. Modelized architecture, fulfills different vendor requirement. To provide easy configuration mechanism to config different kind of applications and different modules. To provide cloud template to adapt public/private cloud. To provide pratical usage examples to facilitate developing.","title":"Advantage"},{"location":"api-reference/ble_apis/","text":"BLE (API List)","title":"BluetoothLE"},{"location":"api-reference/ble_apis/#ble-api-list","text":"","title":"BLE (API List)"},{"location":"api-reference/cloud_apis/","text":"Cloud (API List)","title":"Cloud"},{"location":"api-reference/cloud_apis/#cloud-api-list","text":"","title":"Cloud (API List)"},{"location":"api-reference/ota_apis/","text":"OTA (API List)","title":"OTA"},{"location":"api-reference/ota_apis/#ota-api-list","text":"","title":"OTA (API List)"},{"location":"api-reference/wifi_apis/","text":"WI-FI Network Manager Network Manager provide support for configuring and monitoring WI-FI networking functionality. We stronly recommend using NM, because NM could help network robust. Header File net_mngr.h Functions T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Description Trigger WI-FI scan request, and carried the scan result in indicate callback Parameters fpIndCb : indicate callback function pointer (if required) Returns T_OplErr : see in opl_err.h WI-FI Manager","title":"WI-FI"},{"location":"api-reference/wifi_apis/#wi-fi","text":"","title":"WI-FI"},{"location":"api-reference/wifi_apis/#network-manager","text":"Network Manager provide support for configuring and monitoring WI-FI networking functionality. We stronly recommend using NM, because NM could help network robust.","title":"Network Manager"},{"location":"api-reference/wifi_apis/#header-file","text":"net_mngr.h","title":"Header File"},{"location":"api-reference/wifi_apis/#functions","text":"T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Description Trigger WI-FI scan request, and carried the scan result in indicate callback Parameters fpIndCb : indicate callback function pointer (if required) Returns T_OplErr : see in opl_err.h","title":"Functions"},{"location":"api-reference/wifi_apis/#wi-fi-manager","text":"","title":"WI-FI Manager"},{"location":"application-guide/ble/","text":"BluetoothLE BLE Manager BLE manager provide the auto-advertise option and handling the BLE status that make user eaiser to control BLE statment. Initialize Before using the BLE manager, please follow below steps to initiate. Step 1. Enable BLE manager #define BM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder. Step 2. Add related file in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // initialize ble scan response data APP_BleScanRspDataInit(); break; } case USLCTED_CB_EVT_BLE_ENT_ADVERTISE: { // enter advertising event break; } case USLCTED_CB_EVT_BLE_EXI_ADVERTISE: { // exit advertising event break; } case USLCTED_CB_EVT_BLE_CONNECTED: { // ble connected event break; } case USLCTED_CB_EVT_BLE_DISCONNECT: { // ble disconnect event break; } default: { // should not be here break; } } } void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // ...register your service here // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } The parameter of Opl_Ble_Init_Req() is to enable/disable auto-advertise function. If set as true - the auto-advertise will be enabled, and will directly start advertise after ble manager init done. While disconnect from connected state, ble manager will also start advertising, till user calling Opl_Ble_Stop_Req() . If set as false - the auto-advertise will be disabled, and will not advertise after ble manager init done. Info The APP_BleInit() function create by default in app_main.c , it's for developer to fill the ble related init function in it. Step 4. Setup advertise data void APP_BleAdvDataInit(void) { // ble advertise data inititate // user modify // * uint8_t au8BleAdvertData[]; // configure your own advertise data Opl_Ble_Advertise_Data_Set(au8BleAdvertData, lens); // * } Step 5. Setup scan response data Create scan response data init function, and modify your wishes data. void APP_BleScanRspDataInit(void) { // ble scan response data inititate // user modify // * uint8_t au8BleScanRspData[BLE_ADV_SCAN_BUF_SIZE]; // configure your own scan response data if(OPL_OK != Opl_Ble_ScanRsp_Data_Set(au8BleScanRspData, lens)) { OPL_LOG_ERRO(APP, \"Scan Rsp Data Set Fail\"); } // * } Step 6. Call set adv data & scan rsp data after init Call APP_BleAdvDataInit (created in step 4) and APP_BleScanRspDataInit (created in step 5) after recevied USLCTED_CB_EVT_BLE_INIT event in ble unsolicited callback. void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // <--- // initialize ble scan response data APP_BleScanRspDataInit(); // <--- break; } Unsolicited callback The unsolicited callback will content with ble status and carried the result in each state. Info Unsolicited callback prototype located in ble_mngr_api.h Register service Descript how to create the service file How To... BLE Manager The BLE manager should provide a mechanism for user BLE data processing application to register the user (vendor defined) service table. The user data processing application process the data receive from and transmit to the phone App via BLE. Developer could set a file for specific service in quick_dev\\ble_services How to create BLE service BLE service initiate (e.g. Battery Service) void BAS_Svc_Init(void) { g_tBasSvcHandle.patSvcDb = g_BasSvcDb; g_tBasSvcHandle.u8SvcDbSize = BAS_SVC_IDX_TOTAL; g_tBasSvcHandle.ptSvcGattDispatchHandler = BAS_Svc_GattDispatchHandler; if(OPL_OK != Opl_Ble_Service_Assign(&g_tBasSvcHandle)) { OPL_LOG_ERRO(BAS, \"BAS Service assign fail\\r\\n\"); } } g_tBasSvcHandle is the BLE service handle structure static T_BmSvcHandle g_tBasSvcHandle = {0}; typedef struct S_BmSvcHandle { LE_GATT_SERVICE_T *ptSvcDef; LE_GATT_ATTR_T *patSvcDb; uint8_t u8SvcDbSize; uint8_t u8Reserved; uint16_t u16SvcDataEvtBase; uint16_t u16SvcDataEvtTop; T_BmSvcDataProcessHandlerFp ptSvcDataProcessHandler; T_BmSvcGattDispatchHandlerFp ptSvcGattDispatchHandler; } T_BmSvcHandle; Developer at least should set three parameters *patSvcDb , u8SvcDbSize and ptSvcGattDispatchHandler . *patSvcDb is the service attribute information. u8SvcDbSize is the service size and ptSvcGattDispatchHandler is GATT dispatch handler. LE_GATT_ATTR_T *patSvcDb; typedef struct { UINT16 handle; /**< handle */ UINT8 format; /**< UUID type */ UINT16 * const pUuid; /**< UUID */ UINT16 permit; /**< permit */ UINT16 maxLen; /**< maxinum value length */ UINT16 len; /**< value length */ UINT8 * const pVal; /**< value */ } LE_GATT_ATTR_T; After configurating the BLE handle structure, developer could register BLE service via BLE Manager. Register BLE service via BLE Manager T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle) How to receive/notify data via BLE Developer could create user defined service to implement input/output via BLE. Receive data via BLE In user defined servcie, developer can use user defined GATT dispatch handler to handle data from LE task. The developer can create different handlers for processing according to the type of data received in user defined GATT dispatch handler. static T_OplErr UD_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { UD_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { UD_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { OPL_LOG_INFO(UDS, \"Notify Confirm\"); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } There are three types of events in user defined handler that incude LE_GATT_MSG_ACCESS_READ_IND , LE_GATT_MSG_ACCESS_WRITE_IND and LE_GATT_MSG_NOTIFY_CFM . Developer could create different handler to handle these events. If receiving LE_GATT_MSG_ACCESS_WRITE_IND , developer could create write handler (e.g. UD_Svc_GattDispatchWriteHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessWriteRsp . static void UD_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_TX_VAL: { // send message to app APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case UD_SVC_IDX_RX_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, UD_SVC_IDX_RX_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } LeGattAccessWriteRsp(ind->conn_hdl, ind->flag, ind->handle, u8AttErr); } If receiving LE_GATT_MSG_ACCESS_READ_IND , developer could create read handler (e.g. UD_Svc_GattDispatchReadHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessReadRsp . static void UD_Svc_GattDispatchReadHandler(LE_GATT_MSG_ACCESS_READ_IND_T *ind) { // process the read access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_RX_VAL: case UD_SVC_IDX_RX_CFG: { break; } default: { u8AttErr = LE_ATT_ERR_READ_NOT_PERMITTED; break; } } LeGattAccessReadRsp(ind->conn_hdl, ind->handle, u8AttErr); } Notify data via BLE If wanting to actively send messages from application to the host via BLE, developer can create a notify function (e.g. UD_Svc_RxDataOutNotify ) in the user defined service. LeGattCharValNotify can send data via LE. T_OplErr UD_Svc_RxDataOutNotify(uint8_t *pu8Data, uint32_t u32DataLen) { LE_ERR_STATE status; uint16_t u16NotiAttrId = g_tUdSvcHandle.ptSvcDef->startHdl + UD_SVC_IDX_RX_VAL; // update rx data to attribute value LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, (uint16_t)UD_SVC_IDX_RX_VAL, u32DataLen, pu8Data); // notify rx data to host status = LeGattCharValNotify(Opl_Ble_EntityGet()->conn_hdl, u16NotiAttrId, u32DataLen, pu8Data); if (status != SYS_ERR_SUCCESS) { OPL_LOG_ERRO(BAS, \"Ble sending data fail\"); return OPL_ERR; } return OPL_OK; } How to perform BLE process Start BLE advertising T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn) To start BLE advertising, *u8AutoAdvEn is true that enable auto-advertise while disconnect. Stop BLE advertisng T_OplErr Opl_Ble_Stop_Req(void) Set BLE advertise data T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen) If wanting to set BLE advertisement data via BLE Manager, developer could config BLE data *pau8AdvData in Opl_Ble_Advertise_Data_Set Set BLE scan respnse data T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen) If BLE central scan, developer could set scan response data in BLE perpherial","title":"BluetoothLE"},{"location":"application-guide/ble/#bluetoothle","text":"","title":"BluetoothLE"},{"location":"application-guide/ble/#ble-manager","text":"BLE manager provide the auto-advertise option and handling the BLE status that make user eaiser to control BLE statment.","title":"BLE Manager"},{"location":"application-guide/ble/#initialize","text":"Before using the BLE manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/ble/#step-1-enable-ble-manager","text":"#define BM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder.","title":"Step 1. Enable BLE manager"},{"location":"application-guide/ble/#step-2-add-related-file-in-keil-project","text":"","title":"Step 2. Add related file in Keil project"},{"location":"application-guide/ble/#step-3-register-callback-and-init","text":"Add below program in app_main.c void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // initialize ble scan response data APP_BleScanRspDataInit(); break; } case USLCTED_CB_EVT_BLE_ENT_ADVERTISE: { // enter advertising event break; } case USLCTED_CB_EVT_BLE_EXI_ADVERTISE: { // exit advertising event break; } case USLCTED_CB_EVT_BLE_CONNECTED: { // ble connected event break; } case USLCTED_CB_EVT_BLE_DISCONNECT: { // ble disconnect event break; } default: { // should not be here break; } } } void APP_BleInit(void) { // assign unsolicited callback function Opl_Ble_Uslctd_CB_Reg(&APP_BleUnsolicitedCallback); // register service GAP_Svc_Init(); GATT_Svc_Init(); // ...register your service here // initialize the ble manager (auto-adv) Opl_Ble_Init_Req(true); // user implement } The parameter of Opl_Ble_Init_Req() is to enable/disable auto-advertise function. If set as true - the auto-advertise will be enabled, and will directly start advertise after ble manager init done. While disconnect from connected state, ble manager will also start advertising, till user calling Opl_Ble_Stop_Req() . If set as false - the auto-advertise will be disabled, and will not advertise after ble manager init done. Info The APP_BleInit() function create by default in app_main.c , it's for developer to fill the ble related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/ble/#step-4-setup-advertise-data","text":"void APP_BleAdvDataInit(void) { // ble advertise data inititate // user modify // * uint8_t au8BleAdvertData[]; // configure your own advertise data Opl_Ble_Advertise_Data_Set(au8BleAdvertData, lens); // * }","title":"Step 4. Setup advertise data"},{"location":"application-guide/ble/#step-5-setup-scan-response-data","text":"Create scan response data init function, and modify your wishes data. void APP_BleScanRspDataInit(void) { // ble scan response data inititate // user modify // * uint8_t au8BleScanRspData[BLE_ADV_SCAN_BUF_SIZE]; // configure your own scan response data if(OPL_OK != Opl_Ble_ScanRsp_Data_Set(au8BleScanRspData, lens)) { OPL_LOG_ERRO(APP, \"Scan Rsp Data Set Fail\"); } // * }","title":"Step 5. Setup scan response data"},{"location":"application-guide/ble/#step-6-call-set-adv-data-scan-rsp-data-after-init","text":"Call APP_BleAdvDataInit (created in step 4) and APP_BleScanRspDataInit (created in step 5) after recevied USLCTED_CB_EVT_BLE_INIT event in ble unsolicited callback. void APP_BleUnsolicitedCallback(uint16_t u16EvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { switch(u16EvtType) { case USLCTED_CB_EVT_BLE_INIT: { // ble inited event // initialize ble advertise data APP_BleAdvDataInit(); // <--- // initialize ble scan response data APP_BleScanRspDataInit(); // <--- break; }","title":"Step 6. Call set adv data &amp; scan rsp data after init"},{"location":"application-guide/ble/#unsolicited-callback","text":"The unsolicited callback will content with ble status and carried the result in each state. Info Unsolicited callback prototype located in ble_mngr_api.h","title":"Unsolicited callback"},{"location":"application-guide/ble/#register-service","text":"Descript how to create the service file","title":"Register service"},{"location":"application-guide/ble/#how-to","text":"","title":"How To..."},{"location":"application-guide/ble/#ble-manager_1","text":"The BLE manager should provide a mechanism for user BLE data processing application to register the user (vendor defined) service table. The user data processing application process the data receive from and transmit to the phone App via BLE. Developer could set a file for specific service in quick_dev\\ble_services","title":"BLE Manager"},{"location":"application-guide/ble/#how-to-create-ble-service","text":"BLE service initiate (e.g. Battery Service) void BAS_Svc_Init(void) { g_tBasSvcHandle.patSvcDb = g_BasSvcDb; g_tBasSvcHandle.u8SvcDbSize = BAS_SVC_IDX_TOTAL; g_tBasSvcHandle.ptSvcGattDispatchHandler = BAS_Svc_GattDispatchHandler; if(OPL_OK != Opl_Ble_Service_Assign(&g_tBasSvcHandle)) { OPL_LOG_ERRO(BAS, \"BAS Service assign fail\\r\\n\"); } } g_tBasSvcHandle is the BLE service handle structure static T_BmSvcHandle g_tBasSvcHandle = {0}; typedef struct S_BmSvcHandle { LE_GATT_SERVICE_T *ptSvcDef; LE_GATT_ATTR_T *patSvcDb; uint8_t u8SvcDbSize; uint8_t u8Reserved; uint16_t u16SvcDataEvtBase; uint16_t u16SvcDataEvtTop; T_BmSvcDataProcessHandlerFp ptSvcDataProcessHandler; T_BmSvcGattDispatchHandlerFp ptSvcGattDispatchHandler; } T_BmSvcHandle; Developer at least should set three parameters *patSvcDb , u8SvcDbSize and ptSvcGattDispatchHandler . *patSvcDb is the service attribute information. u8SvcDbSize is the service size and ptSvcGattDispatchHandler is GATT dispatch handler. LE_GATT_ATTR_T *patSvcDb; typedef struct { UINT16 handle; /**< handle */ UINT8 format; /**< UUID type */ UINT16 * const pUuid; /**< UUID */ UINT16 permit; /**< permit */ UINT16 maxLen; /**< maxinum value length */ UINT16 len; /**< value length */ UINT8 * const pVal; /**< value */ } LE_GATT_ATTR_T; After configurating the BLE handle structure, developer could register BLE service via BLE Manager. Register BLE service via BLE Manager T_OplErr Opl_Ble_Service_Assign(T_BmSvcHandle *ptBmSvcHandle)","title":"How to create BLE service"},{"location":"application-guide/ble/#how-to-receivenotify-data-via-ble","text":"Developer could create user defined service to implement input/output via BLE. Receive data via BLE In user defined servcie, developer can use user defined GATT dispatch handler to handle data from LE task. The developer can create different handlers for processing according to the type of data received in user defined GATT dispatch handler. static T_OplErr UD_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { UD_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { UD_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { OPL_LOG_INFO(UDS, \"Notify Confirm\"); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } There are three types of events in user defined handler that incude LE_GATT_MSG_ACCESS_READ_IND , LE_GATT_MSG_ACCESS_WRITE_IND and LE_GATT_MSG_NOTIFY_CFM . Developer could create different handler to handle these events. If receiving LE_GATT_MSG_ACCESS_WRITE_IND , developer could create write handler (e.g. UD_Svc_GattDispatchWriteHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessWriteRsp . static void UD_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_TX_VAL: { // send message to app APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case UD_SVC_IDX_RX_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, UD_SVC_IDX_RX_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } LeGattAccessWriteRsp(ind->conn_hdl, ind->flag, ind->handle, u8AttErr); } If receiving LE_GATT_MSG_ACCESS_READ_IND , developer could create read handler (e.g. UD_Svc_GattDispatchReadHandler ). In this handler, develop must response read access to bottom layer via LE LeGattAccessReadRsp . static void UD_Svc_GattDispatchReadHandler(LE_GATT_MSG_ACCESS_READ_IND_T *ind) { // process the read access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tUdSvcHandle.ptSvcDef->startHdl; // printf(\"UD Svc attId = %d op = %x offset = %d\\r\\n\", u16AttrId, ind->flag, ind->offset); switch(u16AttrId) { case UD_SVC_IDX_RX_VAL: case UD_SVC_IDX_RX_CFG: { break; } default: { u8AttErr = LE_ATT_ERR_READ_NOT_PERMITTED; break; } } LeGattAccessReadRsp(ind->conn_hdl, ind->handle, u8AttErr); } Notify data via BLE If wanting to actively send messages from application to the host via BLE, developer can create a notify function (e.g. UD_Svc_RxDataOutNotify ) in the user defined service. LeGattCharValNotify can send data via LE. T_OplErr UD_Svc_RxDataOutNotify(uint8_t *pu8Data, uint32_t u32DataLen) { LE_ERR_STATE status; uint16_t u16NotiAttrId = g_tUdSvcHandle.ptSvcDef->startHdl + UD_SVC_IDX_RX_VAL; // update rx data to attribute value LeGattChangeAttrVal(g_tUdSvcHandle.ptSvcDef, (uint16_t)UD_SVC_IDX_RX_VAL, u32DataLen, pu8Data); // notify rx data to host status = LeGattCharValNotify(Opl_Ble_EntityGet()->conn_hdl, u16NotiAttrId, u32DataLen, pu8Data); if (status != SYS_ERR_SUCCESS) { OPL_LOG_ERRO(BAS, \"Ble sending data fail\"); return OPL_ERR; } return OPL_OK; }","title":"How to receive/notify data via BLE"},{"location":"application-guide/ble/#how-to-perform-ble-process","text":"Start BLE advertising T_OplErr Opl_Ble_Start_Req(uint8_t u8AutoAdvEn) To start BLE advertising, *u8AutoAdvEn is true that enable auto-advertise while disconnect. Stop BLE advertisng T_OplErr Opl_Ble_Stop_Req(void) Set BLE advertise data T_OplErr Opl_Ble_Advertise_Data_Set(uint8_t *pau8AdvData, uint8_t u8AdvDataLen) If wanting to set BLE advertisement data via BLE Manager, developer could config BLE data *pau8AdvData in Opl_Ble_Advertise_Data_Set Set BLE scan respnse data T_OplErr Opl_Ble_ScanRsp_Data_Set(uint8_t *pau8ScanRspData, uint8_t u8ScanRspDataLen) If BLE central scan, developer could set scan response data in BLE perpherial","title":"How to perform BLE process"},{"location":"application-guide/board_config/","text":"Board Configuration Descript","title":"Board Configuration"},{"location":"application-guide/board_config/#board-configuration","text":"Descript","title":"Board Configuration"},{"location":"application-guide/cloud/","text":"Cloud Cloud Template Descript Porting rule How To...","title":"Cloud"},{"location":"application-guide/cloud/#cloud","text":"","title":"Cloud"},{"location":"application-guide/cloud/#cloud-template","text":"Descript","title":"Cloud Template"},{"location":"application-guide/cloud/#porting-rule","text":"","title":"Porting rule"},{"location":"application-guide/cloud/#how-to","text":"","title":"How To..."},{"location":"application-guide/log_config/","text":"Log Configuration The Log Configuration quick_dev\\common\\log\\log.h is the configuration that package one layer on bottom layer tracer_log in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . The log configuration can help developer to trace and debug in application, the log can divide into four types that are debug, information, warnnimg and error. Developer can turn on the log level that they want to see according to their needs. To enter tracer level <task_index> <task_level:hex> could turn on tracer level in debug mode. If wanting to trace log with Log Configration, the developer could use tracer_def_level_set() to set trcae log. The developer can refer to the following examples static void Main_AppInit_patch(void) { sys_cfg_clk_set(SYS_CFG_CLK_RATE); // set default tracer level in user app type to INFO, WARN, ERRO (DEBG not open) tracer_def_level_set(TRACER_TASK_TYPE_APP, 0x06); APP_MainInit(); } The argument TRACER_TASK_TYPE_APP is a trace type that include TRACER_TASK_TYPE_INTERNAL (bottom layer) and TRACER_TASK_TYPE_APP (application) defined in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . typedef enum { TRACER_TASK_TYPE_INTERNAL = 0, TRACER_TASK_TYPE_APP, TRACER_TASK_TYPE_MAX } T_TracerTaskType; The other argument 0x06 is trace level that developer want to trace. There are the following trace level in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . #define LOG_HIGH_LEVEL 0x04 #define LOG_MED_LEVEL 0x02 #define LOG_LOW_LEVEL 0x01 #define LOG_NONE_LEVEL 0x00 #define LOG_ALL_LEVEL (LOG_HIGH_LEVEL | LOG_MED_LEVEL | LOG_LOW_LEVEL) The argument 0x06 means trace log level turn on LOG_HIGH_LEVEL and LOG_MED_LEVEL but LOG_LOW_LEVEL is turn off. Log Configuration has the following log levels : Debug ( LOG_LOW_LEVEL ) #define OPL_LOG_DEBG(module, ...) \\ { \\ tracer_log(LOG_LOW_LEVEL, \"\\x1B[0m[D][%s]\", #module); \\ tracer_log(LOG_LOW_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_LOW_LEVEL, \"\\r\\n\"); \\ } Info ( LOG_MED_LEVEL ) #define OPL_LOG_INFO(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m[I][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\r\\n\"); \\ } Warn ( LOG_MED_LEVEL ) #define OPL_LOG_WARN(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[33m[W][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } Error ( LOG_HIGH_LEVEL ) #define OPL_LOG_ERRO(module, ...) \\ { \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[31m[E][%s]\", #module); \\ tracer_log(LOG_HIGH_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } The developer could set what module in the argument module . Log configuration can also be set according to the log of which module (e.g. BLE Manager log)the developer wants to see in qd_module.h . Module log enable set (1) (e.g. BM_LOG_ENABLED) #ifndef BM_LOG_ENABLED #define BM_LOG_ENABLED (1) #endif","title":"Log Configuration"},{"location":"application-guide/log_config/#log-configuration","text":"The Log Configuration quick_dev\\common\\log\\log.h is the configuration that package one layer on bottom layer tracer_log in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . The log configuration can help developer to trace and debug in application, the log can divide into four types that are debug, information, warnnimg and error. Developer can turn on the log level that they want to see according to their needs. To enter tracer level <task_index> <task_level:hex> could turn on tracer level in debug mode. If wanting to trace log with Log Configration, the developer could use tracer_def_level_set() to set trcae log. The developer can refer to the following examples static void Main_AppInit_patch(void) { sys_cfg_clk_set(SYS_CFG_CLK_RATE); // set default tracer level in user app type to INFO, WARN, ERRO (DEBG not open) tracer_def_level_set(TRACER_TASK_TYPE_APP, 0x06); APP_MainInit(); } The argument TRACER_TASK_TYPE_APP is a trace type that include TRACER_TASK_TYPE_INTERNAL (bottom layer) and TRACER_TASK_TYPE_APP (application) defined in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . typedef enum { TRACER_TASK_TYPE_INTERNAL = 0, TRACER_TASK_TYPE_APP, TRACER_TASK_TYPE_MAX } T_TracerTaskType; The other argument 0x06 is trace level that developer want to trace. There are the following trace level in sdk\\SDK\\APS\\middleware\\netlink\\msg\\msg.h . #define LOG_HIGH_LEVEL 0x04 #define LOG_MED_LEVEL 0x02 #define LOG_LOW_LEVEL 0x01 #define LOG_NONE_LEVEL 0x00 #define LOG_ALL_LEVEL (LOG_HIGH_LEVEL | LOG_MED_LEVEL | LOG_LOW_LEVEL) The argument 0x06 means trace log level turn on LOG_HIGH_LEVEL and LOG_MED_LEVEL but LOG_LOW_LEVEL is turn off. Log Configuration has the following log levels : Debug ( LOG_LOW_LEVEL ) #define OPL_LOG_DEBG(module, ...) \\ { \\ tracer_log(LOG_LOW_LEVEL, \"\\x1B[0m[D][%s]\", #module); \\ tracer_log(LOG_LOW_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_LOW_LEVEL, \"\\r\\n\"); \\ } Info ( LOG_MED_LEVEL ) #define OPL_LOG_INFO(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m[I][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\r\\n\"); \\ } Warn ( LOG_MED_LEVEL ) #define OPL_LOG_WARN(module, ...) \\ { \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[33m[W][%s]\", #module); \\ tracer_log(LOG_MED_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_MED_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } Error ( LOG_HIGH_LEVEL ) #define OPL_LOG_ERRO(module, ...) \\ { \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[31m[E][%s]\", #module); \\ tracer_log(LOG_HIGH_LEVEL, __VA_ARGS__); \\ tracer_log(LOG_HIGH_LEVEL, \"\\x1B[0m\\r\\n\"); \\ } The developer could set what module in the argument module . Log configuration can also be set according to the log of which module (e.g. BLE Manager log)the developer wants to see in qd_module.h . Module log enable set (1) (e.g. BM_LOG_ENABLED) #ifndef BM_LOG_ENABLED #define BM_LOG_ENABLED (1) #endif","title":"Log Configuration"},{"location":"application-guide/mp/","text":"MP","title":"MP"},{"location":"application-guide/mp/#mp","text":"","title":"MP"},{"location":"application-guide/ota/","text":"OTA The OTA update mechanism allows a device to update itself based on data received while the normal firmware is running (for example, over Wi-Fi or Bluetooth. OTA via BLE OTA via WI-FI Hot To... How to 1... How to 2...","title":"OTA"},{"location":"application-guide/ota/#ota","text":"The OTA update mechanism allows a device to update itself based on data received while the normal firmware is running (for example, over Wi-Fi or Bluetooth.","title":"OTA"},{"location":"application-guide/ota/#ota-via-ble","text":"","title":"OTA via BLE"},{"location":"application-guide/ota/#ota-via-wi-fi","text":"","title":"OTA via WI-FI"},{"location":"application-guide/ota/#hot-to","text":"How to 1... How to 2...","title":"Hot To..."},{"location":"application-guide/project_config/","text":"Project Configuration There are two configuration concepts qd_config.h and qd_module.h in this topic. In qd_config, we help developers classify some system configurations, among which power save is the key point. We use the concept of modularity to include the configuration method in qd_module.h About 'qd_config.h' OPL Chip ID check #if defined(OPL1000_A2) || defined(OPL1000_A3) #else #error \"no define chip id in global definition in 'Preprocessor Symbols'\" #endif RF power setting configuration #ifndef RF_CFG_DEF_PWR_SET #define RF_CFG_DEF_PWR_SET (RF_PWR_LVL_A0) #endif System configuration Set Power save mode #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif There are three default types of SYS_CFG_PS_MODE that 0 means Low Power, 1 means Balance, 2 means Performance, else means user define if choosing user define. There are the following configurations that need to be manually configured by the developer if choosing else. Smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif Mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif Wi-Fi dtim period time #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif Auto-connect retry interval #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif About 'qd_module.h' The developer can choose to use the desired module in qd_module.h Network Manager module If wanting to use Network Manager module to implement Wi-Fi process, the developer could set NM_ENABLED (1). At the same time, the developer must set Wi-Fi Manager module on that set WM_ENABLED (1). #ifndef NM_ENABLED #define NM_ENABLED (1) #endif The developer could only use Wi-Fi Manager module to implement Wi-Fi process if the developer don't use Network Manager module. Set NM_ENABLED (0) and WM_ENABLED (1). Wi-Fi Manager module #ifndef WM_ENABLED #define WM_ENABLED (1) #endif BLE Manager module If wanting to use BLE Manager module, the developer sets BM_ENABLED (1). #ifndef BM_ENABLED #define BM_ENABLED (1) #endif Time stamp module If wanting to use Time stamp module, the developer sets TIME_STMP_ENABLED (1). #ifndef TIME_STMP_ENABLED #define TIME_STMP_ENABLED (1) #endif Finite state machine If using Wi-Fi Manager module and BLE manager module, the developer must use Finite state machine module that set FSM_ENABLED (1). #ifndef FSM_ENABLED #define FSM_ENABLED (1) #endif","title":"Project Configuration"},{"location":"application-guide/project_config/#project-configuration","text":"There are two configuration concepts qd_config.h and qd_module.h in this topic. In qd_config, we help developers classify some system configurations, among which power save is the key point. We use the concept of modularity to include the configuration method in qd_module.h","title":"Project Configuration"},{"location":"application-guide/project_config/#about-qd_configh","text":"OPL Chip ID check #if defined(OPL1000_A2) || defined(OPL1000_A3) #else #error \"no define chip id in global definition in 'Preprocessor Symbols'\" #endif RF power setting configuration #ifndef RF_CFG_DEF_PWR_SET #define RF_CFG_DEF_PWR_SET (RF_PWR_LVL_A0) #endif System configuration Set Power save mode #ifndef SYS_CFG_PS_MODE #define SYS_CFG_PS_MODE (2) #endif There are three default types of SYS_CFG_PS_MODE that 0 means Low Power, 1 means Balance, 2 means Performance, else means user define if choosing user define. There are the following configurations that need to be manually configured by the developer if choosing else. Smart sleep enable #ifndef PS_ENABLED #define PS_ENABLED (1) #endif Mac layer sleep after got ip #ifndef PS_MAC_LAY_ENABLED #define PS_MAC_LAY_ENABLED (1) #endif Wi-Fi dtim period time #ifndef WM_DTIM_PERIOD_TIME #define WM_DTIM_PERIOD_TIME (3000) #endif Auto-connect retry interval #ifndef WM_AC_RETRY_INTVL_TBL static uint32_t g_u32WmAcRetryIntvlTbl[5] = { 30000, 30000, 60000, 60000, 900000, }; #define WM_AC_RETRY_INTVL_TBL (g_u32WmAcRetryIntvlTbl) #endif","title":"About 'qd_config.h'"},{"location":"application-guide/project_config/#about-qd_moduleh","text":"The developer can choose to use the desired module in qd_module.h Network Manager module If wanting to use Network Manager module to implement Wi-Fi process, the developer could set NM_ENABLED (1). At the same time, the developer must set Wi-Fi Manager module on that set WM_ENABLED (1). #ifndef NM_ENABLED #define NM_ENABLED (1) #endif The developer could only use Wi-Fi Manager module to implement Wi-Fi process if the developer don't use Network Manager module. Set NM_ENABLED (0) and WM_ENABLED (1). Wi-Fi Manager module #ifndef WM_ENABLED #define WM_ENABLED (1) #endif BLE Manager module If wanting to use BLE Manager module, the developer sets BM_ENABLED (1). #ifndef BM_ENABLED #define BM_ENABLED (1) #endif Time stamp module If wanting to use Time stamp module, the developer sets TIME_STMP_ENABLED (1). #ifndef TIME_STMP_ENABLED #define TIME_STMP_ENABLED (1) #endif Finite state machine If using Wi-Fi Manager module and BLE manager module, the developer must use Finite state machine module that set FSM_ENABLED (1). #ifndef FSM_ENABLED #define FSM_ENABLED (1) #endif","title":"About 'qd_module.h'"},{"location":"application-guide/wifi/","text":"WI-FI Descript of WI-FI manager & Network Manager & Auto-Connect Network Manager Network manager can handling wifi manager & auto-connect interactive behavior to let user only care about triggering WI-FI scan request and connect request. Info To see the usage example of Network Manager, can check in qd_app in examples\\start_up\\ folder. The network manager initiation will also initialize the wifi manager and auto-connect. It's not necessary to initiate again in application Initialize Before using the network manager, please follow below steps to initiate. Step 1. Enable network manager #define WM_ENABLED (1) #define NM_ENABLED (1) #define AC_ENABLED (1) The definition been defined in qd_config.h in sys_config folder. Warning WM_ENABLED and AC_ENABLED are both required if using network manager. (The AC_ENABLED definition will be force to set as true while NM_ENABLED been set.) Step 2. Add related files in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_NmUnsolicitedCallback(T_NmUslctdEvtType tEvtType, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to net_mngr_api.h switch(tEvtType) { case NM_USLCTD_EVT_NETWORK_UP: { // wifi connected & got ip event break; } case NM_USLCTD_EVT_NETWORK_DOWN: { // wifi disconnect event break; } case NM_USLCTD_EVT_NETWORK_RESET: { // wifi reset event break; } default: { // should not be here break; } } } void APP_NetInit(void) { // Network manager initialize (auto-connect enable) APP_NmInit(true, &APP_NmUnsolicitedCallback); // user implement } The first parameter of APP_NmInit() is to enable/disable auto-connect at started. If set as true - the auto-connect will directly be funtional in sequence. If set as false - the auto-connect won't active. Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it. Unsolicited callback & Indicate callback There're two types of callback function pointer can be assign to Network manager Unsolicited callback - Used for recving unsolicited events from network manager, will be called in network up (Wi-Fi connected & IP got)/ network down/ WI-FI reset. Info network up event represents to WI-FI connected and got dhcp ip Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to network manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in nm_mngr_api.h WI-FI Manager WI-FI manager provide a easy way to control WI-FI. Info Network manager runs base on WI-FI manager, so if using the network manager the WI-FI manager will be directly initiate at network manager initiation. Initialize Before using the WI-FI manager, please follow below steps to initiate. Step 1. Enable WI-FI manager #define WM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder. Step 2. Add related files in Keil project Step 3. Register callback and init Add below program in app_main.c void APP_WmUnsolicitedCallback(T_WmUslctedEvtType tEvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to wifi_mngr_api.h switch(tEvtType) { case USLCTED_CB_EVT_WIFI_UP: { // wifi connected event break; } case USLCTED_CB_EVT_WIFI_DOWN: { // wifi disconnect event break; } case USLCTED_CB_EVT_WIFI_RESET: { // wifi reset event break; } case USLCTED_CB_EVT_GOT_IP: { // wifi got ip break; } } } void APP_WifiInitDoneIndCallback(T_OplErr tEvtRst) { APP_SendMessage(APP_EVT_WIFI_INIT_DONE, (uint8_t*)&tEvtRst, sizeof(T_OplErr)); } void APP_NetInit(void) { // register Wi-Fi unsolicited callback if(OPL_OK != Opl_Wifi_Uslctd_CB_Reg(APP_WmUnsolicitedCallback)) { OPL_LOG_ERRO(APP, \"Wi-Fi unsolicited callback regist fail\"); } // Wi-Fi manager initialize Opl_Wifi_Init_Req(APP_WifiInitDoneIndCallback); // user implement } Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it. Unsolicited callback & Indicate callback There're two types of callback function pointer can be assign to WI-FI manager Unsolicited callback - Used for recving unsolicited events from WI-FI, will happens in WI-FI connected/ disconnected/ reset/ got ip. Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to WI-FI manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in wifi_mngr_api.h Auto-Connect The auto-connect will do automatically connect to stored AP while the WI-FI connection offline, and will periodcially to retry till connected or been disable. Initialize Enable auto-connect and add related file into Keil project #define WM_ENABLED (1) #define AC_ENABLED (1) Info The auto-Connect will be init while initating WI-FI manager. Usage See in API reference How To... Network Manager Network Manager provides mechanism to configure and monitor Wi-Fi networking. We strongly recommend applying Network Manager due to the Network Manager could make the process more robustly. Once the Network Manager initialize done, developer could start to perform the network process via Network Manager How to perform Wi-Fi scan WI-FI scan request via Network Manager T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information. How to perform Wi-Fi connection according to the scan result WI-FI connect via Network Manager T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptWmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Network Manager, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWmWifiCnctConfig with scan result ptScanList typedef struct S_NmWifiCnctConfig { uint8_t u8aBssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t u8aSsid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t u8SsidLen; uint8_t u8aPwd[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t u8PwdLen; // The length of the password. If the length is 64, the password is regarded as PMK. uint8_t u8Timeout; // Connect timeout } T_NmWifiCnctConfig; WI-FI Manager It is not necessary to access Wi-Fi Manager if Network Manager is enabled. However, developer can disable Network Manager and apply Wi-Fi Manager to perform network process directly. Before performing any Wi-Fi operation, developer should trigger Wi-Fi initial first. How to perform Wi-Fi initiate Wi-Fi initiate via Wi-Fi manager T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that initiate is done. After receiving, application can trigger the following Wi-Fi operation. Both user application and the auto-connect module might trigger Wi-Fi operation. The user application should turn off auto-connect module before trigger any Wi-Fi operation. WI-FI auto connect disable request T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb) If blActDisconnect is true that disable auto-connect module. Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect disable done. Once user Wi-Fi operation completed, application can turn on auto-connect module again. WI-FI auto connect enable request T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect enable done. How to perform Wi-Fi scan WI-FI scan request via Wi-Fi Manager T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Configurate scan configuration ptWifiScanConfig typedef struct { uint8_t *ssid; /**< SSID of AP */ uint8_t *bssid; /**< MAC address of AP, point to array[WIFI_MAC_ADDRESS_LENGTH] */ uint8_t channel; /**< channel, scan the specific channel */ bool show_hidden; /**< enable to scan AP whose SSID is hidden */ wifi_scan_type_t scan_type; /**< scan type, active or passive */ wifi_scan_time_t scan_time; /**< scan time per channel */ } wifi_scan_config_t; The ssid and bssid could be empty if developer want to scan global APs. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information. How to perform Wi-Fi connect according to the scan result WI-FI connect request via WI-FI Manager T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Wi-Fi, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWifiConnConfig with scan result ptScanList typedef struct S_WmConnConfig { uint8_t ssid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t ssid_length; // The length of the SSID. uint8_t bssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t password[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t password_length; // The length of the password. If the length is 64, the password is regarded as PMK. } __attribute__((packed)) T_WmConnConfig;","title":"WI-Fi"},{"location":"application-guide/wifi/#wi-fi","text":"Descript of WI-FI manager & Network Manager & Auto-Connect","title":"WI-FI"},{"location":"application-guide/wifi/#network-manager","text":"Network manager can handling wifi manager & auto-connect interactive behavior to let user only care about triggering WI-FI scan request and connect request. Info To see the usage example of Network Manager, can check in qd_app in examples\\start_up\\ folder. The network manager initiation will also initialize the wifi manager and auto-connect. It's not necessary to initiate again in application","title":"Network Manager"},{"location":"application-guide/wifi/#initialize","text":"Before using the network manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/wifi/#step-1-enable-network-manager","text":"#define WM_ENABLED (1) #define NM_ENABLED (1) #define AC_ENABLED (1) The definition been defined in qd_config.h in sys_config folder. Warning WM_ENABLED and AC_ENABLED are both required if using network manager. (The AC_ENABLED definition will be force to set as true while NM_ENABLED been set.)","title":"Step 1. Enable network manager"},{"location":"application-guide/wifi/#step-2-add-related-files-in-keil-project","text":"","title":"Step 2. Add related files in Keil project"},{"location":"application-guide/wifi/#step-3-register-callback-and-init","text":"Add below program in app_main.c void APP_NmUnsolicitedCallback(T_NmUslctdEvtType tEvtType, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to net_mngr_api.h switch(tEvtType) { case NM_USLCTD_EVT_NETWORK_UP: { // wifi connected & got ip event break; } case NM_USLCTD_EVT_NETWORK_DOWN: { // wifi disconnect event break; } case NM_USLCTD_EVT_NETWORK_RESET: { // wifi reset event break; } default: { // should not be here break; } } } void APP_NetInit(void) { // Network manager initialize (auto-connect enable) APP_NmInit(true, &APP_NmUnsolicitedCallback); // user implement } The first parameter of APP_NmInit() is to enable/disable auto-connect at started. If set as true - the auto-connect will directly be funtional in sequence. If set as false - the auto-connect won't active. Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/wifi/#unsolicited-callback-indicate-callback","text":"There're two types of callback function pointer can be assign to Network manager Unsolicited callback - Used for recving unsolicited events from network manager, will be called in network up (Wi-Fi connected & IP got)/ network down/ WI-FI reset. Info network up event represents to WI-FI connected and got dhcp ip Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to network manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in nm_mngr_api.h","title":"Unsolicited callback &amp; Indicate callback"},{"location":"application-guide/wifi/#wi-fi-manager","text":"WI-FI manager provide a easy way to control WI-FI. Info Network manager runs base on WI-FI manager, so if using the network manager the WI-FI manager will be directly initiate at network manager initiation.","title":"WI-FI Manager"},{"location":"application-guide/wifi/#initialize_1","text":"Before using the WI-FI manager, please follow below steps to initiate.","title":"Initialize"},{"location":"application-guide/wifi/#step-1-enable-wi-fi-manager","text":"#define WM_ENABLED (1) The definition been defined in qd_module.h in sys_config folder.","title":"Step 1. Enable WI-FI manager"},{"location":"application-guide/wifi/#step-2-add-related-files-in-keil-project_1","text":"","title":"Step 2. Add related files in Keil project"},{"location":"application-guide/wifi/#step-3-register-callback-and-init_1","text":"Add below program in app_main.c void APP_WmUnsolicitedCallback(T_WmUslctedEvtType tEvtType, T_OplErr tEvtRst, uint8_t *pu8Data, uint32_t u32DataLen) { // tEvtType refer to wifi_mngr_api.h switch(tEvtType) { case USLCTED_CB_EVT_WIFI_UP: { // wifi connected event break; } case USLCTED_CB_EVT_WIFI_DOWN: { // wifi disconnect event break; } case USLCTED_CB_EVT_WIFI_RESET: { // wifi reset event break; } case USLCTED_CB_EVT_GOT_IP: { // wifi got ip break; } } } void APP_WifiInitDoneIndCallback(T_OplErr tEvtRst) { APP_SendMessage(APP_EVT_WIFI_INIT_DONE, (uint8_t*)&tEvtRst, sizeof(T_OplErr)); } void APP_NetInit(void) { // register Wi-Fi unsolicited callback if(OPL_OK != Opl_Wifi_Uslctd_CB_Reg(APP_WmUnsolicitedCallback)) { OPL_LOG_ERRO(APP, \"Wi-Fi unsolicited callback regist fail\"); } // Wi-Fi manager initialize Opl_Wifi_Init_Req(APP_WifiInitDoneIndCallback); // user implement } Info The APP_NetInit() function create by default in app_main.c , it's for developer to fill the network related init function in it.","title":"Step 3. Register callback and init"},{"location":"application-guide/wifi/#unsolicited-callback-indicate-callback_1","text":"There're two types of callback function pointer can be assign to WI-FI manager Unsolicited callback - Used for recving unsolicited events from WI-FI, will happens in WI-FI connected/ disconnected/ reset/ got ip. Unsolicited callback carried... Event, Result, Data & DataLens (Descript) Indicate callback - Used for getting solicited events of each request to send to WI-FI manager (such as scan_req). Indicate callback carried... Result (Descript) Info Unsolicited callback & Indicate callback prototype located in wifi_mngr_api.h","title":"Unsolicited callback &amp; Indicate callback"},{"location":"application-guide/wifi/#auto-connect","text":"The auto-connect will do automatically connect to stored AP while the WI-FI connection offline, and will periodcially to retry till connected or been disable.","title":"Auto-Connect"},{"location":"application-guide/wifi/#initialize_2","text":"Enable auto-connect and add related file into Keil project #define WM_ENABLED (1) #define AC_ENABLED (1) Info The auto-Connect will be init while initating WI-FI manager.","title":"Initialize"},{"location":"application-guide/wifi/#usage","text":"See in API reference","title":"Usage"},{"location":"application-guide/wifi/#how-to","text":"","title":"How To..."},{"location":"application-guide/wifi/#network-manager_1","text":"Network Manager provides mechanism to configure and monitor Wi-Fi networking. We strongly recommend applying Network Manager due to the Network Manager could make the process more robustly. Once the Network Manager initialize done, developer could start to perform the network process via Network Manager","title":"Network Manager"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-scan","text":"WI-FI scan request via Network Manager T_OplErr APP_NmWifiScanReq(T_NmScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information.","title":"How to perform Wi-Fi scan"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-connection-according-to-the-scan-result","text":"WI-FI connect via Network Manager T_OplErr APP_NmWifiCnctReq(T_NmWifiCnctConfig *ptWmWifiCnctConfig, T_NmCnctIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Network Manager, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWmWifiCnctConfig with scan result ptScanList typedef struct S_NmWifiCnctConfig { uint8_t u8aBssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t u8aSsid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t u8SsidLen; uint8_t u8aPwd[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t u8PwdLen; // The length of the password. If the length is 64, the password is regarded as PMK. uint8_t u8Timeout; // Connect timeout } T_NmWifiCnctConfig;","title":"How to perform Wi-Fi connection according to the scan result"},{"location":"application-guide/wifi/#wi-fi-manager_1","text":"It is not necessary to access Wi-Fi Manager if Network Manager is enabled. However, developer can disable Network Manager and apply Wi-Fi Manager to perform network process directly. Before performing any Wi-Fi operation, developer should trigger Wi-Fi initial first.","title":"WI-FI Manager"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-initiate","text":"Wi-Fi initiate via Wi-Fi manager T_OplErr Opl_Wifi_Init_Req(T_WaInitDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that initiate is done. After receiving, application can trigger the following Wi-Fi operation. Both user application and the auto-connect module might trigger Wi-Fi operation. The user application should turn off auto-connect module before trigger any Wi-Fi operation. WI-FI auto connect disable request T_OplErr Opl_Wifi_AC_Disable_Req(bool blActDisconnect, T_AcDisableIndCbFp fpIndCb) If blActDisconnect is true that disable auto-connect module. Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect disable done. Once user Wi-Fi operation completed, application can turn on auto-connect module again. WI-FI auto connect enable request T_OplErr Opl_Wifi_AC_Enable_Req(T_AcEnableIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application Wi-Fi auto-connect enable done.","title":"How to perform Wi-Fi initiate"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-scan_1","text":"WI-FI scan request via Wi-Fi Manager T_OplErr Opl_Wifi_Scan_Req(wifi_scan_config_t *ptWifiScanConfig, T_WaScanDoneIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that scan is done. After receiving, application can retrieve the scan result and trigger the following Wi-Fi connection operation. Configurate scan configuration ptWifiScanConfig typedef struct { uint8_t *ssid; /**< SSID of AP */ uint8_t *bssid; /**< MAC address of AP, point to array[WIFI_MAC_ADDRESS_LENGTH] */ uint8_t channel; /**< channel, scan the specific channel */ bool show_hidden; /**< enable to scan AP whose SSID is hidden */ wifi_scan_type_t scan_type; /**< scan type, active or passive */ wifi_scan_time_t scan_time; /**< scan time per channel */ } wifi_scan_config_t; The ssid and bssid could be empty if developer want to scan global APs. Retrieve WI-FI scan result T_OplErr WM_WaScanListGet(wifi_scan_list_t *ptScanList) This structure ptScanList defines the list of scanned APs with their corresponding information.","title":"How to perform Wi-Fi scan"},{"location":"application-guide/wifi/#how-to-perform-wi-fi-connect-according-to-the-scan-result","text":"WI-FI connect request via WI-FI Manager T_OplErr Opl_Wifi_Conn_Req(T_WmConnConfig *ptWifiConnConfig, T_WaConnectIndCbFp fpIndCb) Inside the callback fpIndCb , developer can send message to inform application that connect is done. Developer could receive unsolicited events from Wi-Fi, including connected/ disconnected/ reset/ got ip. Configurate connect configuration ptWifiConnConfig with scan result ptScanList typedef struct S_WmConnConfig { uint8_t ssid[WIFI_MAX_LENGTH_OF_SSID]; // The SSID of the target AP. uint8_t ssid_length; // The length of the SSID. uint8_t bssid[WIFI_MAC_ADDRESS_LENGTH]; // The MAC address of the target AP. uint8_t password[WIFI_LENGTH_PASSPHRASE]; // The password of the target AP. uint8_t password_length; // The length of the password. If the length is 64, the password is regarded as PMK. } __attribute__((packed)) T_WmConnConfig;","title":"How to perform Wi-Fi connect according to the scan result"},{"location":"application-guide/wifi_provision_via_ble/","text":"WI-FI provision via BLE This block diagram introduces how to provision Wi-Fi credentials of the Home AP via the Bluetooth low energy (BLE). When the phone (ble central) wants to execute wi-fi provision via ble, it can send wi-fi provision message to BLE Application via BLE Manager. BLE Appication is responsible for parsing the Wi-Fi provision message and sending it to the Network manager for processing according to different events (eg. Wi-Fi scan or Wi-Fi connect). Finally, pass the corresponding response (e.g. scan list result) to the BLE Application via the call back function of Network Manager and then pass it to the phone (BLE central) via BLE Manager. The developer can refer to QD_APP Provision Process Creates an user defined service (e.g. quick_dev\\app_ref\\opl_svc.c ) The user defined service could create a gatt handler (e.g. OPL_Svc_GattDispatchHandler() ) to pass Wi-Fi provision message from phone (BLE central) to BLE Application. The developer can refer to BluetoothLE Use BLE Application receive handler in application The developer can use BLE Application receive handler OPL_DataRecvHandler(uint8_t *pu8Data, uint16_t u16DataLen) to send Wi-Fi provision message to BLE Application quick_dev\\app_ref\\ble_data_prot\\opl_data_prot.c when BLE Application gets Wi-Fi provision message, it parses this message and then send this parsed message to Network Manager to excute Wi-Fi request. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } How to... How to create an user defined servic service (e.g. quick\\app_ref\\ble_data_prot\\opl_svc.c ) in BLE Manager Please refer to BluetoothLE How to receive BLE data in and then export to BLE Application in application Create a gatt dispatch handler (e.g. OPL_Svc_GattDispatchHandler() ) in user defined service static T_OplErr OPL_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { OPL_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { OPL_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_TO_PEER_CFM, NULL, 0, 0); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } This example is receiving LE_GATT_MSG_ACCESS_WRITE_IND event to handle BLE data via OPL_Svc_GattDispatchWriteHandler() tatic void OPL_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tOplSvcHandle.ptSvcDef->startHdl; switch(u16AttrId) { case OPL_SVC_IDX_DATA_IN_VAL: { APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case OPL_SVC_IDX_DATA_OUT_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tOplSvcHandle.ptSvcDef, OPL_SVC_IDX_DATA_OUT_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } If receiving OPL_SVC_IDX_DATA_IN_VAL , OPL_Svc_GattDispatchWriteHandler() could send BLE data to application via APP_SendMessage() In application, developer could create a function (e.g. APP_EvtHandler_BleDataInd() ) to send BLE data to BLE Application. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); } How to handle Wi-Fi provision message via BLE in BLE Application BLE Application is responsible for parsing the messages from BLE, and then processing these events by category. Wi-Fi provision messages include Wi-Fi scan, Wi-Fi connect, Wi-Fi disconnect, Wi-Fi reconnect, read device Wi-Fi information, write Wi-Fi device information, get device Wi-Fi status and reset Wi-Fi. It is a BLE Application event handler table g_tOplDataEventHandlerTbl to handle these events. static T_OplDataEventTable g_tOplDataEventHandlerTbl[] = { {OPL_DATA_REQ_SCAN, OPL_DataProtocol_Scan}, {OPL_DATA_REQ_CONNECT, OPL_DataProtocol_Connect}, {OPL_DATA_REQ_DISCONNECT, OPL_DataProtocol_Disconnect}, {OPL_DATA_REQ_RECONNECT, OPL_DataProtocol_Reconnect}, {OPL_DATA_REQ_READ_DEVICE_INFO, OPL_DataProtocol_ReadDeviceInfo}, {OPL_DATA_REQ_WRITE_DEVICE_INFO, OPL_DataProtocol_WriteDeviceInfo}, {OPL_DATA_REQ_WIFI_STATUS, OPL_DataProtocol_WifiStatus}, {OPL_DATA_REQ_RESET, OPL_DataProtocol_Reset}, For example, if receiving OPL_DATA_REQ_SCAN , OPL_DataProtocol_Scan handler will send Wi-Fi scan message to Network Manager to execute Wi-Fi scan. static void OPL_DataProtocol_Scan(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_SCAN\"); // reset connection config table memset(&g_tOplDataConnCfg, 0, sizeof(T_OplDataConnCfg)); g_tOplDataConnCfg.u8ConnectType = OPL_DATA_CONN_TYPE_BSSID; // trigger scan request APP_NmWifiScanReq(OPL_DataHandler_WifiScanDoneIndCb); } How to respnose Wi-Fi process result to phone (BLE central) BLE Application send Wi-Fi provision message to Network Manager, and then Network Manager will create a callback function (e.g. OPL_DataHandler_WifiScanDoneIndCb ) to handle indicate callback. For example, if Wi-Fi scan done, the Wi-FI scan done callback OPL_DataHandler_WifiScanDoneIndCb will send scan done result to phone via BLE Manager.","title":"WI-FI Provision Via BLE"},{"location":"application-guide/wifi_provision_via_ble/#wi-fi-provision-via-ble","text":"This block diagram introduces how to provision Wi-Fi credentials of the Home AP via the Bluetooth low energy (BLE). When the phone (ble central) wants to execute wi-fi provision via ble, it can send wi-fi provision message to BLE Application via BLE Manager. BLE Appication is responsible for parsing the Wi-Fi provision message and sending it to the Network manager for processing according to different events (eg. Wi-Fi scan or Wi-Fi connect). Finally, pass the corresponding response (e.g. scan list result) to the BLE Application via the call back function of Network Manager and then pass it to the phone (BLE central) via BLE Manager. The developer can refer to QD_APP","title":"WI-FI provision via BLE"},{"location":"application-guide/wifi_provision_via_ble/#provision-process","text":"Creates an user defined service (e.g. quick_dev\\app_ref\\opl_svc.c ) The user defined service could create a gatt handler (e.g. OPL_Svc_GattDispatchHandler() ) to pass Wi-Fi provision message from phone (BLE central) to BLE Application. The developer can refer to BluetoothLE Use BLE Application receive handler in application The developer can use BLE Application receive handler OPL_DataRecvHandler(uint8_t *pu8Data, uint16_t u16DataLen) to send Wi-Fi provision message to BLE Application quick_dev\\app_ref\\ble_data_prot\\opl_data_prot.c when BLE Application gets Wi-Fi provision message, it parses this message and then send this parsed message to Network Manager to excute Wi-Fi request. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); }","title":"Provision Process"},{"location":"application-guide/wifi_provision_via_ble/#how-to","text":"","title":"How to..."},{"location":"application-guide/wifi_provision_via_ble/#how-to-create-an-user-defined-servic-service-eg-quickapp_refble_data_protopl_svcc-in-ble-manager","text":"Please refer to BluetoothLE","title":"How to create an user defined servic service (e.g. quick\\app_ref\\ble_data_prot\\opl_svc.c) in BLE Manager"},{"location":"application-guide/wifi_provision_via_ble/#how-to-receive-ble-data-in-and-then-export-to-ble-application-in-application","text":"Create a gatt dispatch handler (e.g. OPL_Svc_GattDispatchHandler() ) in user defined service static T_OplErr OPL_Svc_GattDispatchHandler(MESSAGEID tId, MESSAGE tMsg) { switch(tId) { case LE_GATT_MSG_ACCESS_READ_IND: { OPL_Svc_GattDispatchReadHandler((LE_GATT_MSG_ACCESS_READ_IND_T *)tMsg); break; } case LE_GATT_MSG_ACCESS_WRITE_IND: { OPL_Svc_GattDispatchWriteHandler((LE_GATT_MSG_ACCESS_WRITE_IND_T *)tMsg); break; } case LE_GATT_MSG_NOTIFY_CFM: { Opl_Ble_Send_Message(OPL_SVC_EVT_SEND_TO_PEER_CFM, NULL, 0, 0); break; } default: { return OPL_ERR_CASE_INVALID; } } return OPL_OK; } This example is receiving LE_GATT_MSG_ACCESS_WRITE_IND event to handle BLE data via OPL_Svc_GattDispatchWriteHandler() tatic void OPL_Svc_GattDispatchWriteHandler(LE_GATT_MSG_ACCESS_WRITE_IND_T *ind) { // process the write access activity in each characteristic uint8_t u8AttErr = 0; uint16_t u16AttrId = ind->handle - g_tOplSvcHandle.ptSvcDef->startHdl; switch(u16AttrId) { case OPL_SVC_IDX_DATA_IN_VAL: { APP_SendMessage(APP_EVT_BLE_DATA_IND, ind->pVal, ind->len); break; } case OPL_SVC_IDX_DATA_OUT_CFG: { uint16_t u16Enable = *((uint16_t *)ind->pVal); if ((ind->len == 2) && (u16Enable <= 1)) { LeGattChangeAttrVal(g_tOplSvcHandle.ptSvcDef, OPL_SVC_IDX_DATA_OUT_CFG, sizeof(u16Enable), &u16Enable); } else { u8AttErr = LE_ATT_ERR_INVALID_ATTR_VALUE_LEN; } break; } default: { u8AttErr = LE_ATT_ERR_WRITE_NOT_PERMITTED; break; } } If receiving OPL_SVC_IDX_DATA_IN_VAL , OPL_Svc_GattDispatchWriteHandler() could send BLE data to application via APP_SendMessage() In application, developer could create a function (e.g. APP_EvtHandler_BleDataInd() ) to send BLE data to BLE Application. static void APP_EvtHandler_BleDataInd(uint32_t u32EventId, void *pData, uint32_t u32DataLen) { OPL_DataRecvHandler(pData, (uint16_t)u32DataLen); }","title":"How to receive BLE data in and then export to BLE Application in application"},{"location":"application-guide/wifi_provision_via_ble/#how-to-handle-wi-fi-provision-message-via-ble-in-ble-application","text":"BLE Application is responsible for parsing the messages from BLE, and then processing these events by category. Wi-Fi provision messages include Wi-Fi scan, Wi-Fi connect, Wi-Fi disconnect, Wi-Fi reconnect, read device Wi-Fi information, write Wi-Fi device information, get device Wi-Fi status and reset Wi-Fi. It is a BLE Application event handler table g_tOplDataEventHandlerTbl to handle these events. static T_OplDataEventTable g_tOplDataEventHandlerTbl[] = { {OPL_DATA_REQ_SCAN, OPL_DataProtocol_Scan}, {OPL_DATA_REQ_CONNECT, OPL_DataProtocol_Connect}, {OPL_DATA_REQ_DISCONNECT, OPL_DataProtocol_Disconnect}, {OPL_DATA_REQ_RECONNECT, OPL_DataProtocol_Reconnect}, {OPL_DATA_REQ_READ_DEVICE_INFO, OPL_DataProtocol_ReadDeviceInfo}, {OPL_DATA_REQ_WRITE_DEVICE_INFO, OPL_DataProtocol_WriteDeviceInfo}, {OPL_DATA_REQ_WIFI_STATUS, OPL_DataProtocol_WifiStatus}, {OPL_DATA_REQ_RESET, OPL_DataProtocol_Reset}, For example, if receiving OPL_DATA_REQ_SCAN , OPL_DataProtocol_Scan handler will send Wi-Fi scan message to Network Manager to execute Wi-Fi scan. static void OPL_DataProtocol_Scan(uint16_t type, uint8_t *data, int len) { OPL_LOG_DEBG(OPL, \"OPL_DATA_REQ_SCAN\"); // reset connection config table memset(&g_tOplDataConnCfg, 0, sizeof(T_OplDataConnCfg)); g_tOplDataConnCfg.u8ConnectType = OPL_DATA_CONN_TYPE_BSSID; // trigger scan request APP_NmWifiScanReq(OPL_DataHandler_WifiScanDoneIndCb); }","title":"How to handle Wi-Fi provision message via BLE in BLE Application"},{"location":"application-guide/wifi_provision_via_ble/#how-to-respnose-wi-fi-process-result-to-phone-ble-central","text":"BLE Application send Wi-Fi provision message to Network Manager, and then Network Manager will create a callback function (e.g. OPL_DataHandler_WifiScanDoneIndCb ) to handle indicate callback. For example, if Wi-Fi scan done, the Wi-FI scan done callback OPL_DataHandler_WifiScanDoneIndCb will send scan done result to phone via BLE Manager.","title":"How to respnose Wi-Fi process result to phone (BLE central)"},{"location":"examples/ble_example/","text":"BLE example BLE example is intended to demonstrate the BLE functionality, and to provide code that you can copy and adapt into your own projects BLE battery service This example uses the module to implement a battery service with a battery level characteristic. During initialization, it starts system timers and adds battery services and battery level characteristic. After the timer timeout, the device will notify the client the battery level characteristics. BLE data input/output service When the user sends data, the data will be sent to the Le task first. Then Le task will pass the data into the GattDispatchHandler in User define Service. According data's access permission that include read, write or notify, developer could create different handler to handle. This example use write handler GattWriteHandler to handle write access data from phone (APP). GattWriteHandler will be responsible for passing the data to the application, and the application will return the respnose to the phone (APP) via DataoutNotify.","title":"BLE"},{"location":"examples/ble_example/#ble-example","text":"BLE example is intended to demonstrate the BLE functionality, and to provide code that you can copy and adapt into your own projects","title":"BLE example"},{"location":"examples/ble_example/#ble-battery-service","text":"This example uses the module to implement a battery service with a battery level characteristic. During initialization, it starts system timers and adds battery services and battery level characteristic. After the timer timeout, the device will notify the client the battery level characteristics.","title":"BLE battery service"},{"location":"examples/ble_example/#ble-data-inputoutput-service","text":"When the user sends data, the data will be sent to the Le task first. Then Le task will pass the data into the GattDispatchHandler in User define Service. According data's access permission that include read, write or notify, developer could create different handler to handle. This example use write handler GattWriteHandler to handle write access data from phone (APP). GattWriteHandler will be responsible for passing the data to the application, and the application will return the respnose to the phone (APP) via DataoutNotify.","title":"BLE data input/output service"},{"location":"examples/qd_app_example/","text":"QD APP example QD APP example is the main example of our company's demo, which includes create BLE channel, execute BLE data in & data out, Initialize Wi-Fi via Network Manager, Wi-FI provision via BLE and OTA via BLE in examples\\start_up Create BLE channel During initiation, this example uses BLE Manager to create BLE channel. Execute BLE data in & data out When the data is sent from user\u2019s phone, the data will be transferred to the BLE Mangar through the LE task, and then the BLE Manager will use the OPL_Service to transfer the data to the User Application. If the User Application wants to transfer data to the phone, there are two ways to do it. The first is to use CopytoBuffer to package the data and send the packaged message to user\u2019s phone. The second is to use SendtoPeer to package the data and use notify to transfer the data to user\u2019s phone. Initialize Wi-Fi via Network Manager During initiation, User Application use Network Manager to initialize Wi-Fi. Wi-Fi provision via BLE","title":"QD_APP"},{"location":"examples/qd_app_example/#qd-app-example","text":"QD APP example is the main example of our company's demo, which includes create BLE channel, execute BLE data in & data out, Initialize Wi-Fi via Network Manager, Wi-FI provision via BLE and OTA via BLE in examples\\start_up","title":"QD APP example"},{"location":"examples/qd_app_example/#create-ble-channel","text":"During initiation, this example uses BLE Manager to create BLE channel.","title":"Create BLE channel"},{"location":"examples/qd_app_example/#execute-ble-data-in-data-out","text":"When the data is sent from user\u2019s phone, the data will be transferred to the BLE Mangar through the LE task, and then the BLE Manager will use the OPL_Service to transfer the data to the User Application. If the User Application wants to transfer data to the phone, there are two ways to do it. The first is to use CopytoBuffer to package the data and send the packaged message to user\u2019s phone. The second is to use SendtoPeer to package the data and use notify to transfer the data to user\u2019s phone.","title":"Execute BLE data in &amp; data out"},{"location":"examples/qd_app_example/#initialize-wi-fi-via-network-manager","text":"During initiation, User Application use Network Manager to initialize Wi-Fi.","title":"Initialize Wi-Fi via Network Manager"},{"location":"examples/qd_app_example/#wi-fi-provision-via-ble","text":"","title":"Wi-Fi provision via BLE"},{"location":"examples/wifi_example/","text":"Wi-Fi example Wi-Fi example is intended to demonstrate the Wi-Fi functionality, and to provide code that you can copy and adapt into your own projects Wi-Fi scan connect After APP_init , It will start systemTimer. After timer timeout , User Application will send Scan request to Network Manager. The Network Manager will call the callback function to notify the User Application Scandone after the Scan is completed. Once the Application receives the callback function, the user can use the Scan result to select the desired wifi connection and send a Connect request to the Network Manager, and the Network Manager will call the callback function to notify the User Application after connection done. Wi-Fi quick connect After APP_init, it will start SystemTimer. After timer timeout, User Application will get default SSID and Password from qd_config. Then Network Manager use the AP information to pass to bottom layer that implement WI-FI scan and Network Manager will clear all old AP recorders for saving this AP information to auto-connect if WI-FI disconnect then Network Manager retrieve the scan result (ex: AP bssid) to pass to bottom layer that could use the AP bssid to implement WI-FI connect. By the way, the AP information could be brought by the third party (MCU).","title":"WI-FI"},{"location":"examples/wifi_example/#wi-fi-example","text":"Wi-Fi example is intended to demonstrate the Wi-Fi functionality, and to provide code that you can copy and adapt into your own projects","title":"Wi-Fi example"},{"location":"examples/wifi_example/#wi-fi-scan-connect","text":"After APP_init , It will start systemTimer. After timer timeout , User Application will send Scan request to Network Manager. The Network Manager will call the callback function to notify the User Application Scandone after the Scan is completed. Once the Application receives the callback function, the user can use the Scan result to select the desired wifi connection and send a Connect request to the Network Manager, and the Network Manager will call the callback function to notify the User Application after connection done.","title":"Wi-Fi scan connect"},{"location":"examples/wifi_example/#wi-fi-quick-connect","text":"After APP_init, it will start SystemTimer. After timer timeout, User Application will get default SSID and Password from qd_config. Then Network Manager use the AP information to pass to bottom layer that implement WI-FI scan and Network Manager will clear all old AP recorders for saving this AP information to auto-connect if WI-FI disconnect then Network Manager retrieve the scan result (ex: AP bssid) to pass to bottom layer that could use the AP bssid to implement WI-FI connect. By the way, the AP information could be brought by the third party (MCU).","title":"Wi-Fi quick connect"},{"location":"get_started/get_started/","text":"Get Started Folder structure overview -examples : example applications -quick_dev : Quick-Dev framework program -sdk : Opulinks chip SDK Step 1. SDK download and install Download SDK you needed in Opulinks Github OPL1000_A3: https://github.com/Opulinks-Tech/OPL1000A3-SDK OPL2500_A0: After downloaded, the folder struct of SDK will look like below screenshot. Copy below folder into QD_FWK\\sdk\\ FW_Pack SDK Tool Step 2. Start your first application Now the sdk prepared and ready to go, open the qd_app project in : QD_FWK\\examples\\start_up\\qd_app then into the folder base on the sdk version you just inserted. For example: If download the OPL1000_A3 sdk, then open opl1000_a3 folder in qd_app project. If download the OPL2500_A0 sdk, then open opl2500_a0 folder in qd_app project. Other sdk version likewise. Open qd_app_m3.uvprojx to start Keil application. Step 3. Connect ot Dev-Kit Connect the Dev-Kit via micro-USB Step 4. Configuration setup According to Introduction mention, QD_FWK provide system configure file and module configure option file. To know the detail of the configure file, please check Project Configuration And both file qd_config.h & qd_module.h can be checked in qd_app project. Step 5. Build project Click Build and Rebuild button to compiler project. Output file qd_app_m3.bin located at <project root>\\Output\\Object\\ . Step 6. Download firmware Open download_RELEASE download tool located in sdk\\Tools\\Download\\ In Pack tag insert Script, M0 Bin, M3 Bin files. Script -> PatchData.txt ( sdk\\FW_Pack\\ ) M0 Bin -> opl1000_m0.bin ( sdk\\FW_Pack\\ ) M3 Bin -> qd_app_m3.bin ( <project root>\\Output\\Object ) Will generate opl1000.bin in sdk\\Tool\\Download\\Patch after click Pack button. In OTA tag insert OTA loader, OPL1000 Bin files. OTA loader -> opl1000_ota_loader.bin ( sdk\\FW_Pack\\ ) OPL1000 Bin -> opl1000.bin ( sdk\\Tool\\Download\\Patch\\ ) Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> auto-calculated. Will generate opl1000_ota.bin in sdk\\Tool\\Download\\Patch after click Build OTA Image button. Select UART Port in UART Setting block which connected to Dev-Kit In Download tag insert Patch Bin file to download. Patch Bin -> opl1000_ota.bin ( sdk\\Tool\\Download\\Patch ) Click download and press reset button on Dev-Kit. Step 7. Get log Open terminal (such as Tera-Term or Putty application) and connect to the target COM port and press reset button on Dev-Kit. API support To check supported API provied from QD_FWK, locate to \\app_ref\\mngr_api\\ check the header files. Network manager - \\app_ref\\mngr_api\\net_mngr_api\\net_mngr_api.h WI-FI manager - \\app_ref\\mngr_api\\wifi_mngr_api\\wifi_mngr_api.h BLE manager - \\app_ref\\mngr_api\\ble_mngr_api\\ble_mngr_api.h","title":"Get Started"},{"location":"get_started/get_started/#get-started","text":"","title":"Get Started"},{"location":"get_started/get_started/#folder-structure-overview","text":"-examples : example applications -quick_dev : Quick-Dev framework program -sdk : Opulinks chip SDK","title":"Folder structure overview"},{"location":"get_started/get_started/#step-1-sdk-download-and-install","text":"Download SDK you needed in Opulinks Github OPL1000_A3: https://github.com/Opulinks-Tech/OPL1000A3-SDK OPL2500_A0: After downloaded, the folder struct of SDK will look like below screenshot. Copy below folder into QD_FWK\\sdk\\ FW_Pack SDK Tool","title":"Step 1. SDK download and install"},{"location":"get_started/get_started/#step-2-start-your-first-application","text":"Now the sdk prepared and ready to go, open the qd_app project in : QD_FWK\\examples\\start_up\\qd_app then into the folder base on the sdk version you just inserted. For example: If download the OPL1000_A3 sdk, then open opl1000_a3 folder in qd_app project. If download the OPL2500_A0 sdk, then open opl2500_a0 folder in qd_app project. Other sdk version likewise. Open qd_app_m3.uvprojx to start Keil application.","title":"Step 2. Start your first application"},{"location":"get_started/get_started/#step-3-connect-ot-dev-kit","text":"Connect the Dev-Kit via micro-USB","title":"Step 3. Connect ot Dev-Kit"},{"location":"get_started/get_started/#step-4-configuration-setup","text":"According to Introduction mention, QD_FWK provide system configure file and module configure option file. To know the detail of the configure file, please check Project Configuration And both file qd_config.h & qd_module.h can be checked in qd_app project.","title":"Step 4. Configuration setup"},{"location":"get_started/get_started/#step-5-build-project","text":"Click Build and Rebuild button to compiler project. Output file qd_app_m3.bin located at <project root>\\Output\\Object\\ .","title":"Step 5. Build project"},{"location":"get_started/get_started/#step-6-download-firmware","text":"Open download_RELEASE download tool located in sdk\\Tools\\Download\\ In Pack tag insert Script, M0 Bin, M3 Bin files. Script -> PatchData.txt ( sdk\\FW_Pack\\ ) M0 Bin -> opl1000_m0.bin ( sdk\\FW_Pack\\ ) M3 Bin -> qd_app_m3.bin ( <project root>\\Output\\Object ) Will generate opl1000.bin in sdk\\Tool\\Download\\Patch after click Pack button. In OTA tag insert OTA loader, OPL1000 Bin files. OTA loader -> opl1000_ota_loader.bin ( sdk\\FW_Pack\\ ) OPL1000 Bin -> opl1000.bin ( sdk\\Tool\\Download\\Patch\\ ) Product ID -> select to the target chip series ID. Chip ID -> select to the target chip ID. Firmware ID -> number of current project version. Checksum -> auto-calculated. Will generate opl1000_ota.bin in sdk\\Tool\\Download\\Patch after click Build OTA Image button. Select UART Port in UART Setting block which connected to Dev-Kit In Download tag insert Patch Bin file to download. Patch Bin -> opl1000_ota.bin ( sdk\\Tool\\Download\\Patch ) Click download and press reset button on Dev-Kit.","title":"Step 6. Download firmware"},{"location":"get_started/get_started/#step-7-get-log","text":"Open terminal (such as Tera-Term or Putty application) and connect to the target COM port and press reset button on Dev-Kit.","title":"Step 7. Get log"},{"location":"get_started/get_started/#api-support","text":"To check supported API provied from QD_FWK, locate to \\app_ref\\mngr_api\\ check the header files. Network manager - \\app_ref\\mngr_api\\net_mngr_api\\net_mngr_api.h WI-FI manager - \\app_ref\\mngr_api\\wifi_mngr_api\\wifi_mngr_api.h BLE manager - \\app_ref\\mngr_api\\ble_mngr_api\\ble_mngr_api.h","title":"API support"}]}